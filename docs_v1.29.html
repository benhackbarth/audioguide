




<!DOCTYPE html>
<html>
<head>
<meta name="distribution" content="GLOBAL" />
<meta name="description" content="Ben Hackbarth, composer of electro-acoustic, computer and chamber music. Scores and recordings of compositions" />
<meta name="author" content="Ben Hackbarth" />
<meta charset="utf-8" />
<meta http-equiv="content-language" content="en" />
<title>AudioGuide - Home</title> 

<link rel="stylesheet" href="prism/prism.css">
<script src="prism/prism.js"></script>

<script type="text/javascript" src="http://code.jquery.com/jquery-2.0.2.js"></script>
<link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">
<script type="text/javascript" src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css">

<style type="text/css">
body { padding-top: 70px; }  /* for navbar */


code[class*="language-"],
pre[class*="language-"] {
 white-space: pre-wrap;       /* css-3 */
 white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
 white-space: -pre-wrap;      /* Opera 4-6 */
 white-space: -o-pre-wrap;    /* Opera 7 */
 word-wrap: break-word;       /* Internet Explorer 5.5+ */
}


.group {
}
.group .subgroup {
}
.group .subsubgroup {
}
.fixed {
	position: fixed;
}
/* sidebar */
.bs-docs-mainbar {
	padding-left: 20px;
	margin-bottom: 100px;
}

/* sidebar */
.bs-docs-sidebar {
	padding-left: 20px;
	margin-top: 0px;
	margin-bottom: 20px;
}

/* all links */
.bs-docs-sidebar .nav>li>a {
	color: #999;
	border-left: 2px solid transparent;
	padding: 4px 20px;
	font-size: 13px;
	font-weight: 400;
}

/* nested links */
.bs-docs-sidebar .nav .nav>li>a {
	padding-top: 1px;
	padding-bottom: 1px;
	padding-left: 30px;
	font-size: 12px;
}

/* active & hover links */
.bs-docs-sidebar .nav>.active>a, 
.bs-docs-sidebar .nav>li>a:hover, 
.bs-docs-sidebar .nav>li>a:focus {
	color: #563d7c;                 
	text-decoration: none;          
	background-color: transparent;  
	border-left-color: #563d7c; 
}
/* all active links */
.bs-docs-sidebar .nav>.active>a, 
.bs-docs-sidebar .nav>.active:hover>a,
.bs-docs-sidebar .nav>.active:focus>a {
	font-weight: 500;
}
/* nested active links */
.bs-docs-sidebar .nav .nav>.active>a, 
.bs-docs-sidebar .nav .nav>.active:hover>a,
.bs-docs-sidebar .nav .nav>.active:focus>a {
	font-weight: 500;
}
</style>
<script type='text/javascript'>//<![CDATA[
$(window).load(function(){
$('body').scrollspy({
	target: '.bs-docs-sidebar',
	offset: 40
});
});//]]> 
</script>
</head>





<body>
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">AudioGuide 1.2</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="index.html">Home</a></li>
            <li ><a href="examples.html">Examples</a></li>
            <li ><a href="release.html">Download</a></li>
            <li ><a href="docs.html">Documentation</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>







<div class="container">
	<div class="row">
<!--Main Content -->
<div class="col-xs-9 bs-docs-mainbar">
<p align="center"><h1>AudioGuide1.29 Manual</h1>
By Ben Hackbarth, Norbert Schnell, Philippe Esling, Diemo Schwarz, Gilbert Nouno.<br>
Copyright Ben Hackbarth, 2011-2018.</p><br>



<section id="Installation" class="group"><h2>Installation</h2>
For the moment AudioGuide1.29 only works on OS X.  On more current versions of OS X it should run out of the box with python2 or python3.  Here is a complete list of the resources that AudioGuide1.29 requires on your computer:
<ul>
<li><b>csound6</b> - Needed only if you would like AudioGuide1.29 to automatically render concatenations (which you probably do).  Download an installer from <a href="http://csound.github.io/download.html">here</a>.<li><b>numpy (python >= 2.7 has numpy pre-installed)</b> - Numpy is a numerical computation plugin for Python.  Upgrading to the latest python2.7 will automatically install numpy.  If you don&rsquo;t have it, you can download the source code or a binary installer <a href="http://sourceforge.net/projects/numpy/files/NumPy/">here</a>.<li><b>matlibplot (very optional)</b> - Install this python module to enable graphing of descriptors and soundfile segmentation.  Get it <a href="http://matplotlib.org/downloads.html">here</a>.</ul>
</section>






<section id="QuickStart" class="group"><h2>Quick Start</h2>
We are going to do concatenative synthesis with an excerpt of speech as the target and some music by Helmut Lachenmann as the corpus.  First we need to break the lachenmann soundfile into small chunks, called segments, which will populate our corpus.  Do this by using the agSegmentSf.py script and running the following command in the terminal:
<pre class="language-none"><code class="language-none">python agSegmentSf.py examples/lachenmann.aiff
</code></pre>

Next we run the agConcatenate.py script with an options file.  The options file specifies the target soundfile's path along with a lot of other information which parameterized the concatenative process.


<pre class="language-none"><code class="language-none">python agConcatenate.py examples/01-simplest.py
</code></pre>
The agConcatenate.py script creates several output files with segment selection information.  By default the selected sound segments are also rendered as a soundfile with csound6 and played back at the command line.  Thus, if everything is working you should hear the concatenated soundfile played back after the process is complete.
<br><br>
The reason that segmentation and concatenation are separated into discrete steps that I find is useful to fine-tune the segmentation of corpus sounds <i>before</i> using them in a concatenation.  Soundfile segmentation is a difficult technical problem and should remain conceptually and aesthetically open-ended.  I have yet to find an algorithm that does not require adjustments based on the nature of the sound in question and the intention of the user as to what a segment should be.
</section>    






<section id="CorpusSegmentationwithagSegmentSfpy" class="group"><h2>Corpus Segmentation with agSegmentSf.py</h2>
The script you use to segment your corpus files is called &lsquo;agSegmentSf.py&rsquo;.  AgSegmentSf.py creates textfiles which denote the start and stop times of sound segments in a multi-segment audiofile.  Keep in mind that you do not <i>need</i> to use agSegmentSf.py if you do not want to -- alternatively you could:
<ul>
<li> Use whole soundfiles as corpus segments.  If you only want to use folders of sounds that have been pre-segmented into individual files, you can skip this section and proceed to the <a href="#Concatenating">concatenation</a> section (However make sure tell AudioGuide1.29 not to search for segmentation textfiles by setting the corpus attribute wholeFile=True.  See <a href="#ManipulatingHowDirectoriesAreRead">Manipulating How Directories Are Read</a> for more info.).
<li> Create segmentation files by hand.  You can do this in Audacity with its 'Labels' feature.  Create a label track and indicate the start and end times of desired sound segments.  Then "Export Labels..." and give the outputfile the same name as the soundfile + '.txt'.  So, 'examples/lachenmann.aiff' would need a label file named 'examples/lachenmann.aiff.txt'.
<li> Create segmentation files with other software as long the textfile is written in the same format as AudioGuide1.29&rsquo;s.
</ul>

To segment a corpus file, &lsquo;cd&rsquo; into the AudioGuide1.29 folder and run the following command:

<pre class="language-none"><code class="language-none">python agSegmentSf.py examples/lachenmann.aiff
</code></pre>


AudioGuide1.29 will think for a second, and then output the following data detailing the segmentation of this audiofile:

<pre class="language-none"><code class="language-none">---------------------- AUDIOGUIDE SEGMENT SOUNDFILE ----------------------

Evaluating /Users/ben/Documents/audioguide1.1/examples/lachenmann.aiff from 0.00-64.65

AN ONSET HAPPENS when
The amplitude crosses the Relative Onset Trigger Threshold: -40.00 (-t option)


AN OFFSET HAPPENS when
1. Offset Rise Ratio: when next-frame&rsquo;s-amplitude/this-frame&rsquo;s-amplitude >= 1.30 (-r option)
	...or...
2. Offset dB above minimum: when this frame&rsquo;s absolute amplitude <= -80.00 (minimum found amplitude of -260.00 plus the offset dB boost of 12.00 (-d option))


Found 144 segments
Wrote file /Users/ben/Documents/audioguide1.1/examples/lachenmann.aiff.txt
</code></pre>

As a result of running this python script, AudioGuide1.29 automatically writes a textfile with the exact same name and path as the soundfile, but adding the extension '.txt' -- in this case: examples/lachenmann.aiff.txt.






<div id="FinessingCorpusSegmentation" class="subgroup"><h3>Finessing Corpus Segmentation</h3>
The script &lsquo;agSegmentSf.py&rsquo; gives several options in the form of command line flags for setting different parameters that affect how soundfiles are segmented.  You can read about them by typing &lsquo;python agSegmentSf.py -h&rsquo;.  Segment onsets are determined by the -t flag.  Offsets are determined by a combination of the -d, -a, and -r flags.

<ul>
<li id="flag--t"><b>-t</b> (value <span style="color:green">between -200 and -0</span>; the default is <span style="color:green">-40</span>) - This flag gives the onset trigger threshold value in dB.  When the soundfile's amplitude rises above the threshold, a segment onset is created.  Higher values closer to 0 will lead to fewer onsets.</li><li id="flag--d"><b>-d</b> (value <span style="color:green">between 0 and 100</span>; the default is <span style="color:green">+12</span>) - This flag sets the relative offset trigger threshold.  This value is added to the soundfile’s minimum amplitude.  During segmentation, if a frame’s amplitude is below this threshold, it causes a segment offset. FOr instance, if the lowest amplitude in the soundfile is -82 and -d is set to +12, a dB value of -70 dB will cause a segment offset.  Also see -a.</li><li id="flag--a"><b>-a</b> (value <span style="color:green">between -200 and -0</span>; the default is <span style="color:green">-80</span>) - This flag changes the segmentation offset absolute threshold. When segmenting the target, if a frame's amplitude is below this value it will cause an offset. This variable is an absolute value whereas -d specifies a value relative to the soundfile’s minimum amplitude. Effectively, whichever of these two variables is higher will be the offset threshold.  Also seer -d.</li><li id="flag--r"><b>-r</b> (value <span style="color:green">greater than 1</span>; the default is <span style="color:green">1.1</span>) - This flag gives the offset rise ratio.  It causes an offset when the ampltiude of the soundfile in the next frame divded by the amplitude of the current frame is greater than or equal to this ratio.  Therefore if you are in a current sound segment, but the soundfile suddenly gets much louder, the current segment ends.</li></ul>

<pre class="language-none"><code class="language-none">python agSegmentSf.py -t -30 -d 4 soundfilename.wav # sets the threshold to -30. it will produce less onsets then -40 (the default).  also changes the drop dB value to 4 dB above the minimum amplitude found in the entire soundfile, likely leading to longer segments.

python agSegmentSf.py -r 4 soundfilename.wav # changes the rise ratio from the default (1.1) to 4.  This means that a frame's amplitude must be four times louder than the previous one to start a new segment
</code></pre>

Note that to segment a whole directory of soundfiles, you may use wildcard characters in the bash shell, as in:
<pre class="language-none"><code class="language-none">python agSegmentSf.py mydir/*.aiff # create a segmentation file for each aiff file located in mydir/
</code></pre>


The textfiles created by agSegmentSf.py use a segmentation labeling format identical to that of the soundfile editor Audacity.  So, to examine your segments, open lachenmann.aiff in Audacity, then import labels and select &lsquo;examples/lachenmann.aiff.txt&rsquo;.
<p align="left"><img src="image1.png" width=500 height=195></p>
</div>
</section>





<section id="ConcatenatingwithagConcatenatepy" class="group"><h2>Concatenating with agConcatenate.py</h2>
Once you have segmented corpus soundfiles to your satisfaction, you are ready to call the concatenation script agConcatenate.py with a special AudioGuide1.29 options file as the first (and only) argument.  
<br><br>
To run one of the examples in the examples directory, run the following command inside the AudioGuide1.29 directory:
<pre><code>python agConcatenate.py examples/01-simplest.py
</code></pre>

..which will use the options contained in &lsquo;examples/01-simplest.py&rsquo; to parameterize the concatenative algorithm.  In this options file you specify a target sound, the corpus sounds, and (if you like) lots of other options that parameterize the concatenative process.  When run, the &lsquo;agConcatenate.py&rsquo; script will perform the following operations:
<ul>
<li>  Run an ircamdescriptor analysis of the soundfile in the TARGET variable (note: the analysis is only done once -- subsequent usages of this soundfile simply read data from disk.  Analysis files are stored in a directory called &lsquo;audioguide/data/&rsquo; in the AudioGuide1.29 folder.  This directory can become quite large since these files are quite substantial in size.  Removing this folder will cause all analysis files to be recomputed).  
<li>  Segment the target sound according to your options file.  An Audacity-style label file is created in a file called &lsquo;output/tgtlabels.txt&rsquo; in the output directory.
<li>  Run an ircamdescriptor analysis of the soundfiles in the CORPUS variable (only the first time each of these files are used).
<li> (If you&rsquo;ve specified them) Remove corpus segments according to descriptor limitations (Nothing above a certain pitch, nothing below a certain dynamic, etc.).
<li>  Normalise target and corpus descriptor data according to your options file (see "norm" and "normmethod" in the section <a href="#Descriptorsandthedobject">Descriptors and the d() object</a>).
<li>  Go through each target segment one by one.  Select corpus segment(s) to match each target segment according to the descriptors and search passes in the SEARCH variable (see the section <a href="#SEARCHvariable">SEARCH variable and spass() object</a>) of your options file.  Control over the layering and superimposition of corpus sounds is specified in the SUPERIMPOSE variable (see the section <a href="#TheSUPERIMPOSEvariabls">The SUPERIMPOSE variable and si() object</a>).
<li> Write selected segments to a csound score called &lsquo;output/output.csd&rsquo;.  (In addition to the csd file there are many other types of outputs (see the section <a href="#ConcatenationOutputFiles">Concatenation Output Files</a>).
<li> If you have csound, &lsquo;output/output.csd&rsquo; is rendered with csound to create an audiofile called &lsquo;output/output.aiff&rsquo;.
<li> If you have csound, automatic playback of &lsquo;output/output.aiff&rsquo; at the command line.
</ul>

The options file used by the concatenate script is a python file that defines a bunch of variables.  Most variables are simply floats and strings.  For instance, to change the path of the csound output sound file, write the following in your myOptions.py file:
<pre class="language-python"><code class="language-python">CSOUND_RENDER_FILEPATH = '/path/to/the/file/i/want.aiff' # sets the path of the csound output aiff file
DESCRIPTOR_HOP_SIZE_SEC = 0.02049 # change the analysis hop size
</code></pre>

However, there are five custom objects that are written into the options file as well -- tsf(), csf(), spass(), d() and si().  These objects take required parameters and also take keyword arguments.  The following sections describe the object-style variables; Section <a href="#OtherOptions">Other Options</a> details simple variables assigned with the &lsquo;=&rsquo; symbol.






<div id="TheTARGETVariable" class="subgroup"><h3>The TARGET Variable and tsf() object</h3>
The TARGET variable is written as a tsf() object which requires a path to a soundfile and also takes the following optional keyword arguments:

<pre class="language-python"><code class="language-python">tsf('pathtosoundfile', start=0, end=file-length, thresh=-40, offsetRise=1.5, offsetThreshAdd=+12, offsetThreshAbs=-80, scaleDb=0, minSegLen=0.05, maxSegLen=1000, midiPitchMethod='composite', stretch=1, segmentationFilepath=None)
</code></pre>


<ul>
<li><b>start</b> - The time in seconds to start reading the soundfile.<li><b>end</b> - The time in seconds to stop reading the soundfile.  <li><b>thresh</b> - Segmentation onset threshold: a value from -100 to 0. This is equilavent to the function of the <a href="#flag--t">-t flag</a>. <li><b>offsetRise</b> - Segmentation offset ratio: a number greater than 1.  This is equilavent to the function of the <a href="#flag--r">-r flag</a>.<li><b>offsetThreshAdd</b> - Segmentation offset relative threshold: a positive value in dB.  This is equilavent to the function of the <a href="#flag--a">-a flag</a>.<li><b>offsetThreshAbs</b> - Segmentation offset absolute threshold: a negative value in dB.  This is equilavent to the function of the <a href="#flag--d">-d flag</a>.<li><b>minSegLen</b> - Segmentation: the minimum duration in seconds of a target segment.<li><b>maxSegLen</b> - Segmentation: the maximum duration in seconds of a target segment.<li><b>scaleDb</b> - Applies an amplitude change to the whole target sound. By default, it is 0, yielding no change. -6 = twice as soft.  The target&rsquo;s amplitude will usually affect concatenation: the louder the target, the more corpus sounds can be composited to approximate it&rsquo;s energy profile.<li><b>midiPitchMethod</b> - same as corpus method documented <a href="#midiPitchMethod">here</a>.<li><b>stretch</b> - Uses SuperVp to time stretch/compress the target sound before analysis and concatenation.  Stretched sound files are saved and reused in the audioguide/data_stretched_sfs directory.  A value of 1, the default, will cause no time stretching to be applied.  2 will double the duration of the soundfile.  Note that, in order to use this option, you must set the SUPERVP_BIN variable in the audioguide/defaults.py file.<li><b>segmentationFilepath</b> - by default the Target sound is segmented at runtime.  However, if you&rsquo;d like to specify a user-defined segmentation, you may give a file path to this variable.  Note that this file must be a textfile with the same format as corpus segmentation files.</ul>


<pre class="language-python"><code class="language-python">TARGET = tsf('cage.aiff') # uses the whole soundfile at its given amplitude
TARGET = tsf('cage.aiff', start=5, end=7, scaleDb=6) # only use seconds 5-7 of cage.aiff at double the amplitude.
TARGET = tsf('cage.aiff', start=2, end=3, stretch=2) # only uses seconds 2-3, but stretches the sound with supervp to twice its duration before concatenation
</code></pre>
</div>









<div id="TheCORPUSVariable" class="subgroup"><h3>The CORPUS Variable and csf() object</h3>
The CORPUS variable is defined as a list of csf() objects which require a path to a soundfile OR a directory.  File paths and/or directory paths may be full paths or relative paths to the location of the options file you&rsquo;re using or a path found in the SEARCH_PATHS variable.  A csf() object required the soundfile/directory name, then takes the following optional keyword arguments:

<pre class="language-python"><code class="language-python">csf('pathToFileOrDirectoryOfFiles', start=None, end=None, includeTimes=[], excludeTimes=[], limit=[], wholeFile=False, <a href="#ben">recursive</a>=True, includeStr=None, excludeStr=None, scaleDb=0.0, limitDur=None, onsetLen=0.01, offsetLen='30%', postSelectAmpBool=False, postSelectAmpMethod='power-mean-seg', postSelectAmpMin=-12, postSelectAmpMax=+12, midiPitchMethod='composite', transMethod=None,  transQuantize=0, concatFileName=None, allowRepetition=True, restrictRepetition=0.5, restrictOverlaps=None, restrictInTime=0, maxPercentTargetSegments=None, scaleDistance=1, superimposeRule=None, segmentationFile=None, segmentationExtension='.txt')
</code></pre>


The simplest way to include a soundfile in your corpus is to use its path as the first argument of the csf() object:
<pre class="language-python"><code class="language-python">CORPUS = [csf("lachenmann.aiff")]# will search for a segmentation file called lachenmann.aiff.txt and add all of its segments to the corpus
</code></pre>


The simplest way to include a directory of soundfiles in your corpus is to use its path as the first argument of the csf() object:
<pre class="language-python"><code class="language-python">CORPUS = [csf("lachenmann.aiff"), csf('piano')]# will use segments from lachenmann.aiff as well as all sounds in the directory called piano
</code></pre>


However, as you can see above, each csf() object has <i>a lot</i> of optional arguments to give you better control over what segments are used, how directories are read and how segments are treated during concatenation.  
<br><br>
<i>Note: Each of these keyword arguments <i>only</i> apply to the csf() object within which they are written.  If you&rsquo;d like to specify these parameters for the entire corpus, see <a href="#Specifyingcsfkeywordsglobally">Specifying csf() keywords globally</a>.</i>












<div id="Whichsegmentsareaddedtothecorpus" class="subsubgroup"><h4>Which Segments are Added to the Corpus</h4>
Below are csf() keywords which influence which sound segments make it into the corpus.

<ul>
<li><b>start</b> - Any segments which start before this time will be ignored.<li><b>end</b> - Any segments which start after this time will be ignored.<pre class="language-python"><code class="language-python">csf('lachenmann.aiff', start=20) # only use segments who start later than 20s.
csf('lachenmann.aiff', start=20, end=50) # only use segments who start between 20-50s.
</code></pre>
<li><b>includeTimes</b> - A list of two-number lists which specify regions of segments to include from this file&rsquo;s list of segment times.  See example below.<li><b>excludeTimes</b> - Same as includeTimes but excludes segments in the identified regions.
<pre class="language-python"><code class="language-python">csf('lachenmann.aiff', includeTimes=[(1, 4), (10, 12)]) # only use segments falling between 1-4 seconds and 10-12 seconds.
csf('lachenmann.aiff', excludeTimes=[(30, 55)]) # use all segments except those falling between 30-55s.
</code></pre>


<li><b>limit</b> - A list of equation-like strings where segmented descriptor names are used to include/exclude segments from this file / directory.<pre class="language-python"><code class="language-python">csf('lachenmann.aiff', limit=['centroid-seg >= 1000']) # segments whose centroid-seg is equal to or above 1000.

csf('lachenmann.aiff', limit=['centroid-seg < 50%']) # only use 50% of segments with the lowest centroid-seg.

csf('lachenmann.aiff', limit=['power-seg < 50%', 'power-seg > 10%']) # only use segments whose power-seg falls between 10%-50% of the total range of power-seg's in this file/directory.
</code></pre>

<li><b>segmentationFile</b> - Manually specify the segmentation text file. By default, AudioGuide1.29 automatically looks for a file with the same name as the soundfile plus the extension &lsquo;.txt&rsquo;. You may specify a path file (as a string), or a list of strings to include multiple segmentation files which all use the same soundfile.<li><b>segmentationExtension</b> - Manually specify the segmentation text file extension.  See above.</ul>

<pre class="language-python"><code class="language-python">csf('lachenmann.aiff', segmentationFile='marmotTent.txt') # will use a segmentation file called marmotTent.txt, not the default lachenmann.aiff.txt.

csf('lachenmann.aiff', segmentationExtension='-gran.txt') # will use a segmentation file called lachenmann.aiff-gran.txt, not the default lachenmann.aiff.txt.
</code></pre>
</div>









<div id="HowDirectoriesAreRead" class="subsubgroup"><h4>How Directories Are Read</h4>
The following csf() keyword arguments are useful when dealing with directories of files.
<ul>
<li><b>wholeFile</b> - if True AudioGuide1.29 will use this soundfile as one single segment.  If False, AudioGuide1.29 will search for a segmnetation file made with agSegmentSf.py.<pre class="language-python"><code class="language-python">csf('sliced/my-directory', wholeFile=True) # will not search for a segmentation txt file, but use whole soundfiles as single segments.
</code></pre>
<li><b>recursive</b> - if True AudioGuide1.29 will include sounds in all subfolders of a given directory.<pre class="language-python"><code class="language-python">csf('/Users/ben/gravillons', wholeFile=True, recursive=False) # will only use soundfiles in the named folder, ignoring its subdirectories.
</code></pre>
<li><b>includeStr</b> - A string which is matched against the filename (not full path) of each soundfile in a given directory.  If part of the soundfile name matches this string, it is included.  If not it is excluded.  This is case sensitive.  See example below.<li><b>excludeStr</b> - Opposite of includeStr.<pre class="language-python"><code class="language-python"># includeStr/excludeStr have lots of uses.  One to highlight here: working with sample databases which are normalized.  Rather than having each corpus segment be at 0dbs, we apply a scaleDb value based on the presence of a &lsquo;dynamic' written into the filename.
csf('Vienna-harpNotes/', includeStr=['_f_', '_ff_'], scaleDb=-6),
csf('Vienna-harpNotes/', includeStr='_mf_', scaleDb=-18),
csf('Vienna-harpNotes/', includeStr='_p_', scaleDb=-30),
# this will use all sounds from this folder which match one of the three dynamics.
</code></pre>
</ul>
</div>







<div id="HowSegmentsWillBeConcatenated" class="subsubgroup"><h4>How Segments Will Be Concatenated</h4>
Below are csf() keywords which influence how sound segments are treated during concatenation.
<ul>
<li><b>scaleDb</b> - applies an amplitude change to each segment of this collection. by default, it is 0, yielding no change. -6 = twice as soft.  Note that amplitude scaling affects both the concatenative algorithm and the csound rendering.<li><b>limitDur</b> - limits the duration of each segment from this csf() entry.  The duration of all segments over this value (in seconds) will be truncated.  <li><b>onsetLen</b> - if onsetLen is a float or integer, it is the fade-in time in seconds.  If it is a string formed as &rsquo;10%&rsquo;, it is interpreted as a percent of each segment&rsquo;s duration.  So, onsetLen=0.1 yields a 100 ms. attack envelope while onsetLen=&rsquo;50%&rsquo; yields a fade in over 50% of the segment&rsquo;s duration.<li><b>offsetLen</b> - Same as onsetLen, but for the envelope fade out.<pre class="language-python"><code class="language-python">csf('lachenmann.aiff', onsetLen=0.1, offsetLen='50%') # will apply a 100ms fade in time and a fade out time lasting 50% of each segments' duration.
</code></pre>
<li><b>postSelectAmpBool</b> - If True, AudioGuide1.29 will attempt to change the amplitude of selected segments to match the amplitude of the target.  The default, False, makes no adjustment.<li><b>postSelectAmpMethod</b> - Tells AudioGuide1.29 how to attempt to match corpus and target amplitudes.  It is only meaningful if postSelectAmpMethod is True:<ul><li><b>&lsquo;power-mean-seg&rsquo;</b> - will use the mean of segment powers&rsquo; to change adjust selected segments amplitudes. <li><b>&lsquo;power-seg&rsquo;</b> - will adjust amplitudes according to peak amplitudes.  </ul><li><b>postSelectAmpMin</b> - If postSelectAmpBool is True, this value in dB limits the lower threshold of the amplitude change.  0=no change, -6=half volume, etc.<li><b>postSelectAmpMax</b> - If postSelectAmpBool is True, this value in dB limits the upper threshold of the amplitude change.  0=no change, +6=double volume, etc.<li><b><a id="midiPitchMethod"></a>midiPitchMethod</b> - this tells AudioGuide1.29 how got calculate a midipitch for each segment.  There are several possibilities, detailed below.  Note that if any of these methods do not find a result, -1 is returned.  This attribute is used when writing midi output files.  This data is also accessible as the descriptor d('MIDIPitch-seg').<ul><li><b>&lsquo;f0-seg&rsquo;</b> - returns the averaged f0 array as the midipitch.  Note that it is not power weighted - it is actually the median of f0.<li><b>&lsquo;centroid-seg&rsquo;</b> - returns the power averaged centroid converted into a midipitch.<li><b>&lsquo;filename&rsquo;</b> - looks at the filename of the corpus segment to see if there is a midipitch indicated.  Names like A1ShortSeq.wav, Fs1ShortSeq.wav and BP-flatter-f-A\#3.wav work.<li><b>&lsquo;composite&rsquo;</b> - first tries to look for a midipitch in the filename.  If not found, then tries &lsquo;f0-seg&rsquo;.</ul><li><b>transMethod</b> - A string indicating how to transpose segments chosen from this corpus entry.  You may chose from:<ul><li><b>None</b> - yields no transposition.<li><b>&lsquo;single-pitch n&rsquo;</b> - transposes all selected segments from this csf() to midipitch n.<li><b>&lsquo;random n m&rsquo;</b> - transposes this segment randomally between midipitch n and m.<li><b>&lsquo;f0&rsquo;</b> - transposes a selected corpus segment to match the f0-seg of the corresponding target segment.<li><b>&lsquo;f0-chroma&rsquo;</b> - transposes a selected corpus segment to match the f0-seg of the corresponding target segment modulo 12 (i.e., matching its chroma).</ul><li><b>transQuantize</b> - Quantization interval for transposition of corpus sounds.  1 will quantize to semitones, 0.5 to quarter tones, 2 to whole tones, etc.<pre class="language-python"><code class="language-python">csf('piano/', transMethod='f0') # transpose corpus segments to match the target's f0.
csf('piano/', transMethod='f0-chroma', transQuantize=0.5) # transpose corpus segments to match the target's f0 mod 12.  Then quantize each resulting pitch to the newest quarter of tone.
</code></pre>



<li><b>concatFileName</b> - A string indicating a different soundfile path to use when rending with csound.  This means that the first argument of the cps() object is used for soundfile descirptor analysis, but the path found in concatFileName if the soundfile used in the concatenated result.  By default, concatFileName is set to the same filename as the first argument of the cps().
<pre class="language-python"><code class="language-python">csf('lachenmann-mono.aiff', concatFileName='lachenmann.stereo.aiff'), # runs the descriptor analysis on lachenmann-mono.aiff, but then uses the audio from lachenmann.stereo.aiff when rendering the csound output.
</code></pre>


<li><b>allowRepetition</b> - If False, any of the segments from this corpus entry may only be picked one time.  If True there is no restriction.<li><b>restrictRepetition</b> - A delay time in seconds where, once chosen, a segment from this corpus entry is invalid to be picked again.  The default is 0.1, which the same corpus segment from being selected in quick succession.<pre class="language-python"><code class="language-python">csf('piano/', allowRepetition=False) # each individual segment found in this directory of files may only be deleted one time during concatenation.
csf('piano/', restrictRepetition=2.5) # Each segment is invalid to be picked if it has already been selected in the last 2.5 seconds.
</code></pre>

<li><b>restrictOverlaps</b> - An integer specifying how many overlapping samples from this collection may be chosen by the concatenative algorithm at any given moment.  So, restrictOverlaps=2 only permits 2 overlapping voices at a time.<li><b>restrictInTime</b> - a time in seconds specifying how often a sample from this entry may be selected. -- for example restrictInTime=0.5 would permit segments from this collection to be select a maximum of once every 0.5 seconds.<li><b>maxPercentTargetSegments</b> - a float as a percentage value from 0-100.  This number limits the number of target segments that this corpus entry may be selected.  For example, a value of 50 means that this corpus entry is only valid for up to 50% of target segments; after this threshold has been crossed, further selections are not possible.  None is the default, which has no effect.<li><b>scaleDistance</b> - Scale the resulting distance when executing a multidimensional search using on segments.  scaleDistance=2 will make these sounds twice as &lsquo;far&rsquo;, and thus less likely to be selected by the search algorithm.  scaleDistance=0.25 makes 4 times more likely to be picked.<li><b>superimposeRule</b> -  This one is a little crazy.  Basically, you can specify when this corpus&rsquo;s segments can be chosen based on the number of simultaneously selected samples.  You do this by writing a little equation as a 2-item list.  superimposeRule=(&lsquo;==&rsquo;, 0) says that this set of corpus segments may only be chosen is this is the first selection for this target segment (sim selection &lsquo;0&rsquo;).  superimposeRule=(&lsquo;$>$&rsquo;, 2) say this corpus&rsquo;s segments are only valid to by picked if there are already more than 2 selections for this target segment.  I know, right?</ul>
</div>


<div id="Specifyingcsfkeywordsglobally" class="subsubgroup"><h4>Specifying csf() Keywords Globally</h4>
csf() keywords may be specified globally using the variable CORPUS_GLOBAL_ATTRIBUTES.  Note that they are specified in dictionary format rather than object/keyword format.

<pre class="language-python"><code class="language-python">CORPUS = [csf('lachenmann.aiff', scaleDb=-6), csf('piano/', scaleDb=-6, wholeFile=True)]
# is equivalent to 
CORPUS_GLOBAL_ATTRIBUTES = {'scaleDb': -6}
CORPUS = [csf('lachenmann.aiff'), csf('piano/', wholeFile=True)]
</code></pre>
</div>
</div>








<div id="Descriptorsandthedobject" class="subgroup"><h3>Descriptors and the d() object</h3>
Use the d() object to specify a descriptor, how it is weighted, and how it is normalized.  The d() object takes 1 argument -- the name of the desired descriptor --  and then several optional keywords arguments, detailed below.

<pre class="language-python"><code class="language-python">d('descriptor name', weight=1, norm=2, normmethod='stddev', distance='euclidean', energyWeight=False)
</code></pre>

 
<ul>
<li><b>descriptor name</b> - a string of the name of the desired descriptor.  Note that most (but not all) descriptors have both a time varying version as well as a power-weighted averaged version (&lsquo;-seg&rsquo;).  All possible descriptors are listed in <a href="#Appendix1Descriptors">Appendix 1</a>.<li><b>weight</b> - How to weight this descriptor in relation to other descriptors.<pre class="language-python"><code class="language-python">SEARCH= [spass('closest', d('centroid', weight=1), d('noisiness', weight=0.5))]# centroid is twice as important as noisiness.
</code></pre>


<li><b>norm</b> - A value of 2 normalizes the target and corpus data separately.  A value of 1 normalizes the target and corpus data together.  2 will yield a better rendering of the target&rsquo;s morphological contour.  1 will remain more faithful to concrete descriptor values.  I recommend using 2 by default, only using 1 when dealing with very &lsquo;descriptive&rsquo; descriptors like duration or pitch.
<pre class="language-python"><code class="language-python">SEARCH = [spass('closest', d('centroid'), d('effDur-seg', norm=1))]
</code></pre>


<li><b>normmethod</b> - How to normalize data -- either &lsquo;stddev&rsquo; or &lsquo;minmax&rsquo;.  minmax is more precise, stddev is more forgiving of &lsquo;outliers.&rsquo;<li><b>distance</b> - Only valid for time-varying descriptors.  How to arithmetically measure distance between target and corpus arrays.<ul>
<li><b>&lsquo;euclidean&rsquo;</b> - does a simple least squares distance.<li><b>&lsquo;pearson&rsquo;</b> - a pearson correlation measurement.</ul>

<pre class="language-python"><code class="language-python">SEARCH = [spass('closest', d('centroid', distance='pearson'))] # uses a pearson correlation formula for determining distance between target and corpus centroid arrays.
</code></pre>


<li><b>energyWeight</b> - Only valid for time-varying descriptors.  Weight distance calculations with the corpus segments&rsquo; energy values.  The means that softer frames will not affect distance as much as louder frames.  Only works if distance=&lsquo;euclidean&rsquo;.</ul>
</div>



<!-- 

<h2 id="Normalisation">Normalisation</h2>
Use the d() object to specify a descriptor, how it is weighted, and how it is normalized.  The d() object takes 1 argument -- the name of the desired descriptor --  and then several optional keywords arguments, detailed below.

<pre class="language-python"><code class="language-python">
d('descriptor name', weight=1, norm=2, normmethod='stddev', distance='euclidean', energyWeight=False)



d('f0-seg', normmethod='minmax', energyWeight=True) 
</code></pre>


 -->





<div id="SEARCHvariable" class="subgroup"><h3>SEARCH variable and spass() object</h3>
The SEARCH variable tells AudioGuide1.29 how to pick corpus segments to match target segments.  The idea here is make a <i>very</i> flexible searching structure where the user can create multiple search passes based on different descriptor criteria.

The SEARCH variable is a list of spass() objects.  Each spass() has the following parameters: 
<pre class="language-python"><code class="language-python">spass(search_type, descriptor1...descriptorN, percent=None, minratio=None, maxratio=None)
</code></pre>

<ul>
<li><b>search_type</b> - describes what kind of search to perform, among the following methods:	<ul><li><b>&lsquo;closest&rsquo;</b> - Return the best matching segment.<li><b>&lsquo;closest_percent&rsquo;</b> - Return the top <i>percent</i> percent of the best matching segments.<li><b>&lsquo;farthest&rsquo;</b> - Return the worst matching segment.<li><b>&lsquo;farthest_percent&rsquo;</b> - Return the worst <i>percent</i> percent of segments.<li><b>&lsquo;ratio_limit&rsquo;</b> - Return segments where the ratio of the target descriptor value to the segment&rsquo;s value falls between minratio and maxratio.  Only works for averaged descriptors.	</ul><li><b>descriptor1...descriptorN</b> - a series of d() objects of any length.  If there is only d() object, similarity will be judged according to the difference between taget and corpus descriptor distances.  If there are mutiple descriptors listed, each descriptor will be equally important in determining which segments match.  The d() objects 'weight' keyword can further influence which samples are selected where there are mutiple descriptors.<li><b>percent</b> - Only valid when search_type='closest_percent' or 'farthest_percent' where this keyword sets the percentage of segments that may pass through this spass() object.<li><b>minratio</b> - Only valid when search_type='ratio_limit' where this keyword sets the minimum allowable ratio.<li><b>maxratio</b> - Only valid when search_type='ratio_limit' where this keyword sets the maximum allowable ratio.</ul>


Here is the most simple case of a SEARCH variable:
<pre class="language-python"><code class="language-python">SEARCH = [spass('closest', d('centroid'))] # will search all corpus segments and select the one with the &lsquo;closest' time varying centroid to the target segment.
</code></pre>


Note that the first argument is the type of search performed -- in this case, selecting the closest sample.  Following the arguments are a list of descriptor objects which specify which descriptors to use:

<pre class="language-python"><code class="language-python">SEARCH = [spass('closest', d('centroid'), d('effDur-seg'))] # will search all corpus segments and select the one with the &lsquo;closest' centroid and effective duration compared to the target segment.
</code></pre>


Ok, great.  As you can probably imagine, the first argument, &lsquo;closest&rsquo;, tells AudioGuide1.29 to pick the closest sound.  But, there are also other possibilities:

<pre class="language-python"><code class="language-python">SEARCH = [spass('farthest', d('centroid'))] # return the worst matching segment.

SEARCH = [spass('closest_percent', d('centroid'), percent=20)] # return the top 20 percent best matches.

SEARCH = [spass('farthest_percent', d('centroid'), percent=20)] # return the worst 20 percent of matches.

SEARCH = [spass('ratio_limit', d('centroid-seg'), minratio=0.5)] # return segments who's centroid-seg is at least half the value of the target's centroid-seg
</code></pre>


If you use &lsquo;closest_percent&rsquo; or &lsquo;farthest_percent&rsquo; as the one and only spass object in the SEARCH variable, AudioGuide1.29 will select a corpus segment randomly among the final candidates.  However, you can also chain spass objects together, essentially constructing a hierarchical search algorithm.  So, for example, take the following SEARCH variable with two separate phases:

<pre class="language-python"><code class="language-python">SEARCH = [
spass('closest_percent', d('effDur-seg'), percent=20), # take the best 20% of matches from the corpus
spass('closest', d('mfccs')), # now find the best matching segment from the 20 percent that remains.
]
</code></pre>


I use the above example a lot when using AudioGuide1.29.  It first matches effDur-seg, the effective duration of the target measured agains&rsquo;t the effective duration of each corpus segment.  It retains the 20% closest matches, and throws away the worst 80%.  Then, with the remaining 20%, the timbre of the sounds are matched according to mfccs.

<pre class="language-python"><code class="language-python">SEARCH = [spass('ratio_limit', d('centroid-seg'), minratio=0.9, maxratio=1.1)] # reduce the number of samples in the corpus such 
</code></pre>


Remember, the order of the spass objects in the SEARCH variable is very important -- it is essentially the order of operations.
</div>







<div id="TheSUPERIMPOSEvariabls" class="subgroup"><h3>The SUPERIMPOSE variable and si() object</h3>
Use the si() object for specifying how corpus segments may be superimposed during concatenation.

<pre class="language-python"><code class="language-python">SUPERIMPOSE = si(minSegment=None, maxSegment=None, minOnset=None, maxOnset=8, minOverlap=None, maxOverlap=None, searchOrder='power', calcMethod='mixture', peakAlign=False)
</code></pre>

 
<ul>
<li><b>minSegment</b> - The minimum number of corpus segments that must be chosen to match a target segment.<li><b>maxSegment</b> - The maximum number of corpus segments that must be chosen to match a target segment.<li><b>minOnset</b> - The minimum number of corpus segments that must be chosen to begin at any single moment in time.<li><b>maxOnset</b> - The maximum number of corpus segments that must be chosen to begin at any single moment in time.<li><b>minOverlap</b> - The minimum number of overlapping corpus segments at any single moment in time.  Note that an &lsquo;overlap&rsquo; is determined according to an amplitude threshold -- see overlapAmpThresh.<li><b>maxOverlap</b> - The maximum number of overlapping corpus segments at any single moment in time.  Note that an &lsquo;overlap&rsquo; is determined according to an amplitude threshold -- see overlapAmpThresh.<li><b>searchOrder</b> - (&lsquo;power&rsquo; or &lsquo;time&rsquo;)  The default is &lsquo;time&rsquo;, which indicated to match corpus segments to target segments in the temporal order of the target (i.e., first searched segment is the first segment in time).  &lsquo;power&rsquo; indicates to first sort the target segments from loudest to softest, then search for corpus matches.<li><b>calcMethod</b> - A None/string which denotes how to calculate overlapping corpus sounds.  None does nothing -- each corpus selection is unaware of previous selections.  &lsquo;subtract&rsquo; subtracts the energy of a selected corpus sound from the target&rsquo;s amplitude so that future selections factor in the amplitude of past selections.  &lsquo;mixture&rsquo; subtracts the amplitude and then attempts to mix the descriptors of simultaneous sounds together.  Note that some descriptors are not algorithmically mixable, such as f0, zeroCross.</ul>
</div>







<div id="OtherOptions" class="subgroup"><h3>Other Options</h3>



<div id="DescriptorComputationParameters" class="subsubgroup"><h4>Descriptor Computation Parameters</h4>
<p><b>DESCRIPTOR_FORCE_ANALYSIS</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">False</span>) if True, AudioGuide1.29 is forced to remake all analysis file, even if previously made.</p><p><b>DESCRIPTOR_WIN_SIZE_SEC</b> (type=<span style="color:red">float</span>, default=<span style="color:green">0.04096</span>) the FFT window size of descriptor analysis in seconds.  0.04096 seconds = 512 @ 12.5kHz (the default resample rate).</p><p><b>DESCRIPTOR_HOP_SIZE_SEC</b> (type=<span style="color:red">float</span>, default=<span style="color:green">0.01024</span>) the FFT window overlaps of descriptor analysis in seconds.  Important, as it effectively sets of temporal resolution of AudioGuide1.29.</p><p><b>IRCAMDESCRIPTOR_RESAMPLE_RATE</b> (type=<span style="color:red">int</span>, default=<span style="color:green">25000</span>) The internal resample rate of the IRCAM analysis binary.  Important, as it sets the frequency resolution of spectral sound descriptors.</p><p><b>IRCAMDESCRIPTOR_WINDOW_TYPE</b> (type=<span style="color:red">string</span>, default=<span style="color:green">&lsquo;blackman&rsquo;</span>) see ircamdescriptor documentation for details.</p><p><b>IRCAMDESCRIPTOR_NUMB_MFCCS</b> (type=<span style="color:red">int</span>, default=<span style="color:green">13</span>) sets the number of MFCCs to make.  <i>Doesn&rsquo;t seem to work</i> in this release, as 13 is all I can ever seem to get out of the library.</p><p><b>IRCAMDESCRIPTOR_F0_MAX_ANALYSIS_FREQ</b> (type=<span style="color:red">float</span>, default=<span style="color:green">5000</span>) see ircamdescriptor documentation for details.</p><p><b>IRCAMDESCRIPTOR_F0_MIN_FREQUENCY</b> (type=<span style="color:red">float</span>, default=<span style="color:green">20</span>) minimum possible f0 frequency.</p><p><b>IRCAMDESCRIPTOR_F0_MAX_FREQUENCY</b> (type=<span style="color:red">float</span>, default=<span style="color:green">5000</span>) maximum possible f0 frequency.</p><p><b>IRCAMDESCRIPTOR_F0_QUALITY</b> (type=<span style="color:red">float</span>, default=<span style="color:green">0.1</span>) see ircamdescriptor documentation for details.</p><p><b>SUPERVP_BIN</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) Optionally specify a path to the supervp analysis binary.  Used for target pre-concatenation time stretching.</p>

</div>









<div id="Concatenation" class="subsubgroup"><h4>Concatenation</h4>
<p><b>ROTATE_VOICES</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">False]</span>) if True, AudioGuide1.29 will rotate through the list of corpus entries during concatenation.  This means that, when selecting corpus segment one, AudioGuide1.29 will only search sound segments from the first item of the CORPUS variable.  Selection 2 will only search the second, and so on.  Corpus rotation is modular around the length of the CORPUS variable.  If the corpus only has one item, True will have no effect.</p><p><b>VOICE_PATTERN</b> (type=<span style="color:red">list</span>, default=<span style="color:green">[]</span>) if an empty list, this does nothing.  However, if the user gives a list of strings, AudioGuide1.29 will rotate through this list of each concatenative selection and only use corpus segments who&rsquo;s filepath match this string.  Matching can use parts of the filename, not necessarily the whole path and it is not case sensitive.</p><p><b>OUTPUT_QUANTIZE_TIME_METHOD</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) controls the quantisation of the start times of events selected during concatenation.  Note that any quantisation takes place after the application of OUTPUT_TIME_STRETCH and OUTPUT_TIME_ADD, as detailed below.  This variable has the following possible settings:</p><ul><li><b>None</b> - no quantisation takes place (the default).<li><b>&lsquo;snapToGrid&rsquo;</b> - conform the start times of events to a grid spaced in OUTPUT_QUANTIZE_TIME_INTERVAL second slices.<li><b>&lsquo;medianAggregate&rsquo;</b> - change each event&rsquo;s start time to the median start time of events in slices of OUTPUT_QUANTIZE_TIME_INTERVAL seconds.</ul><p><b>OUTPUT_QUANTIZE_TIME_INTERVAL</b> (type=<span style="color:red">float</span>, default=<span style="color:green">0.25</span>) defines the temporal interval in seconds for quantisation.  If OUTPUT_QUANTIZE_TIME_METHOD = None, this doesn&rsquo;t do anything.</p><p><b>OUTPUT_GAIN_DB</b> (type=<span style="color:red">int/None</span>, default=<span style="color:green">None</span>) adds a uniform gain in dB to all selected corpus units.  Affects the subtractive envelope calculations and descriptor mixtures as well as csound rendering.</p><p><b>OUTPUT_TIME_STRETCH</b> (type=<span style="color:red">float</span>, default=<span style="color:green">1.</span>) stretch the temporality of selected units.  A value of 2 will stretch all events offsets by a factor of 2.</p><p><b>OUTPUT_TIME_ADD</b> (type=<span style="color:red">float</span>, default=<span style="color:green">0.</span>) offset the start time of selected events by a value in seconds.</p><p><b>RANDOM_SEED</b> (type=<span style="color:red">int/None</span>, default=<span style="color:green">None</span>) sets the pseudo-random seed for random unit selection.  By default a value of None will use the system&rsquo;s timestamp.  Setting an integer will create repeatable random results.</p>

</div>







<div id="ConcatenationOutputFiles" class="subsubgroup"><h4>Concatenation Output Files</h4>
For each of the following _FILEPATH variables, a value of None tells the agConcatenate.py NOT to create an output file.  Otherwise a string tells agConcatenate.py to create this output file and also indicates the path of the file to create.  Strings may be absolute paths.  If a relative path is given, AudioGuide1.29 will create the file relative to the location o the agConcatenate.py script.

<p><b>CSOUND_CSD_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/output.csd&rsquo;</span>) creates an output csd file for rendering the resulting concatenation with csound.</p><p><b>CSOUND_RENDER_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/output.aiff&rsquo;</span>) sets the sound output file in the CSOUND_CSD_FILEPATH file.  This is the name of csound&rsquo;s output soundfile and will be created at the end of concatenation.</p><p><b>MIDI_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/output.mid&rsquo;</span>) a midi file of the concatenation with pitches chosen according to midiPitchMethod from each corpus entry.</p><p><b>OUTPUT_LABEL_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/outputlabels.txt&rsquo;</span>) Audacity-style labels showing the selected corpus sounds and how they overlap.</p><p><b>LISP_OUTPUT_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/output.lisp.txt&rsquo;</span>) a textfile containing selected corpus events as a lisp-style list.</p><p><b>DATA_FROM_SEGMENTATION_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) This file lists all of the extra data of selected events during concatenation.  This data is taken from corpus segmentation files, and includes everything after the startTime and endTime of each segment.  This is useful if you want to tag each corpus segment with text based information for use later.</p><p><b>DICT_OUTPUT_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/output.json&rsquo;</span>) a textfile containing selected corpus events in json format.</p><p><b>MAXMSP_OUTPUT_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/output.maxmsp.json&rsquo;</span>) a textfile containing a list of selected corpus events.  Data includes starttime in MS, duration in MS, filename, transposition, amplitude, etc.</p>

</div>








<div id="OtherOutputFiles" class="subsubgroup"><h4>Other Output Files</h4>
For each of the following _FILEPATH variables, a value of None tells the agConcatenate.py NOT to create an output file.  Otherwise a string tells agConcatenate.py to create this output file and also indicates the path of the file to create.  Strings may be absolute paths.  If a relative path is given, AudioGuide1.29 will create the file relative to the location o the agConcatenate.py script.

<p><b>LOG_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/log.txt&rsquo;</span>) a log file with lots of information from the concatenation algorithm.</p><p><b>TARGET_SEGMENT_LABELS_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">&lsquo;output/targetlabels.txt&rsquo;</span>) Audacity-style labels showing how the target sound was segmented.</p><p><b>TARGET_SEGMENTATION_GRAPH_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) like TARGET_SEGMENT_LABELS_FILEPATH, this variable creates a file to show information about target segmentation.  Here however, the output is a jpg graph of the onset and offset times and the target&rsquo;s power.  This output requires you to install python&rsquo;s module matplotlib.</p><p><b>TARGET_DESCRIPTORS_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) saves the loaded target descriptors to a json dictionary.</p><p><b>TARGET_PLOT_DESCRIPTORS_FILEPATH</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) creates a plot of each target descriptor used in concatenation.  Doesn&rsquo;t create plots for averaged descriptors (&ldquo;-seg&rdquo;), only time varying descriptors.</p>


</div>








<div id="PrintingInteraction" class="subsubgroup"><h4>Printing/Interaction</h4>
<p><b>SEARCH_PATHS</b> (type=<span style="color:red">list</span>, default=<span style="color:green">[]</span>) a list of strings, each of which is a path to a directory where soundfile are located.  These paths extend the list of search paths that AudioGuide1.29 examines when searching for target and corpus soundfiles.  The default is an empty list, which doesn&rsquo;t do anything.</p><p><b>VERBOSITY</b> (type=<span style="color:red">int</span>, default=<span style="color:green">2</span>) affects the amount of information AudioGuide1.29 prints to the terminal.  A value of 0 yields nothing.  A value of 1 prints a minimal amount of information.  A value of 2 (the default) prints refreshing progress bars to indicate the progress of the algorithms.</p><p><b>PRINT_SELECTION_HISTO</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">False</span>) if True will print robust information about corpus selection after concatenation.  If false (the default) will add this information to the log file, if used.</p><p><b>PRINT_SIM_SELECTION_HISTO</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">False</span>) if True will print robust information about corpus overlapping selection after concatenation.  If false (the default) will add this information to the log file, if used.</p>

</div>












<div id="CsoundRendering" class="subsubgroup"><h4>Csound Rendering</h4>
<p><b>CSOUND_SR</b> (type=<span style="color:red">int</span>, default=<span style="color:green">48000</span>) The sample rate used for csound rendering.  Csound will interpolate the sample rates of all corpus files to this rate.  It will be the sr of csound&rsquo;s output soundfile.</p><p><b>CSOUND_BITS</b> (type=<span style="color:red">int</span>, default=<span style="color:green">16</span>) The bitrate of the csound output soundfile.  Valid values are 16, 24, and 32.</p><p><b>CSOUND_KSMPS</b> (type=<span style="color:red">int</span>, default=<span style="color:green">128</span>) The ksmps value used for csound rendering.  See csound&rsquo;s documentation for more information.</p><p><b>CSOUND_NORMALIZE</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">False</span>) If True normalize csound's output soundfile after rendering.</p><p><b>CSOUND_NORMALIZE_PEAK_DB</b> (type=<span style="color:red">float</span>, default=<span style="color:green">-3</span>) If CSOUND_NORMALIZE is True, normalization of this peak dB will take place.</p><p><b>CSOUND_PLAY_RENDERED_FILE</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">True</span>) if True, AudioGuide1.29 will play the rendered csound file at the command line at the end of the concatenative algorithm.</p><p><b>CSOUND_ALIGN_PEAKS</b> (type=<span style="color:red">bool</span>, default=<span style="color:green">False</span>) If True aligns the peak times of corpus segments to match those of the target segment.  Thus, every corpus segment selected to represent a target segment will be moved in time such that corpus segment peaks align in time with the target segment's peak.</p><p><b>CSOUND_SEGMENT_MIN_DUR</b> (type=<span style="color:red">float/None</span>, default=<span style="color:green">None</span>) Sets a minimum playback duration for all selected corpus segments.  When this variable is a float, the length of each segment's playback will be at least CSOUND_SEGMENT_MIN_DUR seconds (unless the soundfile is too short, in which case the duration will be the soundfile's duration).  If None is given (the default), no minimum duration is enforced.</p><p><b>CSOUND_SEGMENT_MAX_DUR</b> (type=<span style="color:red">float/None</span>, default=<span style="color:green">None</span>) Sets a maximum playback duration for all selected corpus segments.  When this variable is a float, the length of each segment's playback cannot be more than CSOUND_SEGMENT_MAX_DUR seconds.  If None is given (the default), no maximum duration is enforced.</p><p><b>CSOUND_STRETCH_CORPUS_TO_TARGET_DUR</b> (type=<span style="color:red">string/None</span>, default=<span style="color:green">None</span>) Affects the durations of concatenated sound events rendered by csound.  By default None doesn&rsquo;t do anything -- csound plays back each corpus sound according to its duration.  &ldquo;pv&rdquo; uses a phase vocoder to stretch corpus sounds to match the duration of the corresponding target segment.  &ldquo;transpose&rdquo; does the same, but using the speed of playback to change duration rather than a phase vocoder.  Note that, in this case, any other transposition information generated by the selection algorithm is overwritten.</p><p><b>CSOUND_CHANNEL_RENDER_METHOD</b> (type=<span style="color:red">string</span>, default=<span style="color:green">mix</span>) Tells AudioGuide1.29 how deal with corpus segments distribution in the output soundfile.  By default&lsquo;&rsquo;mix&rdquo; creates a 2 channel csound file and puts mono corpus sounds in the middle of the stereo field.  The string &ldquo;oneChannelPerVoice&rdquo; tells audioguide to put selected sounds from each item of the CORPUS list into a separate channel.  The number of output channels will therefore equal the length of the CORPUS list variable.</p><p><b>MIDIFILE_TEMPO</b> (type=<span style="color:red">int/float</span>, default=<span style="color:green">60</span>) sets the tempo of the midi file output.</p></div>

</div><!--end other options-->
</section> <!--end conctaet script-->









<section id="DescriptorRetrieval" class="group"><h2>Descriptor Retrieval with agGetSfDescriptors.py</h2>
agGetSfDescriptors.py is a simple script that exports continuous descriptor values of a soundfile.  The output format is a json dictionary.  To use it simply call the script with the soundfile as the first argument and the output path as the second argument.
<pre class="language-none"><code class="language-none">python agGetSfDescriptors.py examples/lachenmann.aiff examples/lachenmann.json
</code></pre>

</section>    














<section id="Appendix1Descriptors" class="group"><h2>Appendix 1 - Descriptors</h2>
The tables below lists all descriptors available in AudioGuide1.29.

<table class="table-striped table-condensed">
<tr><th>Descriptor Description</th><th>AudioGuide Averaged Descriptor</th><th>AudioGuide Time Varying Descriptor</th></tr>
<tr><td>duration</td><td>dur-seg</td><td></td></tr>
<tr><td>effective duration</td><td>effDur-seg<sup><a href="#fn1" id="ref1">1</a></sup></td><td></td></tr>
<tr><td>peak amplitude in frames</td><td>peakTime-seg</td><td></td></tr>
<tr><td>log attack time in seconds</td><td>logAttackTime-seg</td><td></td></tr>
<tr><td>time in file in percent</td><td>percentInFile-seg</td><td></td></tr>
<tr><td>midi pitch from filename</td><td>MIDIPitch-seg<sup><a href="#fn2" id="ref2">2</a></sup></td><td></td></tr>
<tr><td>amplitude</td><td>power-seg, power-mean-seg<sup><a href="#fn3" id="ref3">3</a></sup></td><td>power</td></tr>
<tr><td>spectral centroid</td><td>centroid-seg</td><td>centroid         </td></tr>
<tr><td>combination of 4 spectral crest descriptors</td><td>crests-seg</td><td>crests     </td></tr>
<tr><td>spectral crest coefficient 1 ... 4</td><td>crest0-seg ... crest3-seg</td><td>crest0 ... crest3           </td></tr>
<tr><td>spectral decrease</td><td>decrease-seg</td><td>decrease         </td></tr>
<tr><td>combination of 4 spectral flatness descriptors</td><td>flatnesses-seg</td><td>flatnesses       </td></tr>
<tr><td>spectral flatness coefficient 1 ... 4</td><td>flatness0-seg ... flatness3-seg</td><td>flatness0 ... flatness3        </td></tr>
<tr><td>spectral kurtosis</td><td>kurtosis-seg</td><td>kurtosis</td></tr>
<tr><td>spectral noisiness</td><td>noisiness-seg</td><td>noisiness</td></tr>
<tr><td>spectral rolloff</td><td>rolloff-seg</td><td>rolloff</td></tr>
<tr><td>spectral sharpness</td><td>sharpness-seg</td><td>sharpness</td></tr>
<tr><td>spectral skewness</td><td>skewness-seg</td><td>skewness</td></tr>
<tr><td>spectral slope</td><td>slope-seg</td><td>slope</td></tr>
<tr><td>spectral spread</td><td>spread-seg</td><td>spread</td></tr>
<tr><td>spectral variation</td><td>variation-seg</td><td>variation</td></tr>
<tr><td>fundamental frequency</td><td>f0-seg<sup><a href="#fn4" id="ref4">4</a></sup></td><td>f0</td></tr>
<tr><td>zero crossings</td><td>zeroCross-seg</td><td>zeroCross        </td></tr>
<tr><td>combination of 12 mel frequency cepstral coefficients</td><td>mfccs-seg</td><td>mfccs            </td></tr>
<tr><td>mel frequency cepstral coefficient 1 ... 12</td><td>mfcc0-seg ... mfcc11-seg</td><td>mfcc0 ... mfcc11 </td></tr>
<tr><td>combination of 12 chroma descriptors</td><td>chromas-seg</td><td>chromas          </td></tr>
<tr><td>chroma 1 ... 12</td><td>chroma0-seg ... chroma11-seg</td><td>chroma0 ... chroma11</td></tr>
<tr><td>harmonic spectral centroid</td><td>harmoniccentroid-seg</td><td>harmoniccentroid</td></tr>
<tr><td>harmonic spectral decrease</td><td>harmonicdecrease-seg</td><td>harmonicdecrease</td></tr>
<tr><td>harmonic spectral deviation</td><td>harmonicdeviation-seg</td><td>harmonicdeviation</td></tr>
<tr><td>harmonic spectral kurtosis</td><td>harmonickurtosis-seg</td><td>harmonickurtosis</td></tr>
<tr><td>harmonic spectral odd-even ratio</td><td>harmonicoddevenratio-seg</td><td>harmonicoddevenratio</td></tr>
<tr><td>harmonic spectral rolloff</td><td>harmonicrolloff-seg</td><td>harmonicrolloff</td></tr>
<tr><td>harmonic spectral skewness</td><td>harmonicskewness-seg</td><td>harmonicskewness</td></tr>
<tr><td>harmonic spectral slope</td><td>harmonicslope-seg</td><td>harmonicslope</td></tr>
<tr><td>harmonic spectral spread</td><td>harmonicspread-seg</td><td>harmonicspread</td></tr>
<tr><td>harmonic spectral tristimulus coefficient 1</td><td>harmonictristimulus0-seg</td><td>harmonictristimulus0</td></tr>
<tr><td>harmonic spectral tristimulus coefficient 2</td><td>harmonictristimulus1-seg</td><td>harmonictristimulus1</td></tr>
<tr><td>harmonic spectral tristimulus coefficient 3</td><td>harmonictristimulus2-seg</td><td>harmonictristimulus2</td></tr>
<tr><td>harmonic spectral variation</td><td>harmonicvariation-seg</td><td>harmonicvariation</td></tr>
<tr><td>perceptual spectral centroid</td><td>perceptualcentroid-seg</td><td>perceptualcentroid</td></tr>
<tr><td>perceptual spectral decrease</td><td>perceptualdecrease-seg</td><td>perceptualdecrease</td></tr>
<tr><td>perceptual spectral deviation</td><td>perceptualdeviation-seg</td><td>perceptualdeviation</td></tr>
<tr><td>perceptual spectral kurtosis</td><td>perceptualkurtosis-seg</td><td>perceptualkurtosis</td></tr>
<tr><td>perceptual spectral odd-even ratio</td><td>perceptualoddtoevenratio-seg</td><td>perceptualoddtoevenratio</td></tr>
<tr><td>perceptual spectral rolloff</td><td>perceptualrolloff-seg</td><td>perceptualrolloff</td></tr>
<tr><td>perceptual spectral skewness</td><td>perceptualskewness-seg</td><td>perceptualskewness</td></tr>
<tr><td>perceptual spectral slope</td><td>perceptualslope-seg</td><td>perceptualslope</td></tr>
<tr><td>perceptual spectral spread</td><td>perceptualspread-seg</td><td>perceptualspread</td></tr>
<tr><td>perceptual spectral tristimulus coefficient 1</td><td>perceptualtristimulus0-seg</td><td>perceptualtristimulus0</td></tr>
<tr><td>perceptual spectral tristimulus coefficient 2</td><td>perceptualtristimulus1-seg</td><td>perceptualtristimulus1</td></tr>
<tr><td>perceptual spectral tristimulus coefficient 3</td><td>perceptualtristimulus2-seg</td><td>perceptualtristimulus2</td></tr>
<tr><td>perceptual spectral variation</td><td>perceptualvariation-seg</td><td>perceptualvariation</td></tr>
</table>
<br>
<sup id="fn1"><a href="#ref1">1</a>. effDur-seg ignores silences whereas dur-seg does not</sup><br>
<sup id="fn2"><a href="#ref2">2</a>. myfileC4.wav=60, basooonFs2.wav=42, HA_ES_mu_Ab6_p.wav=92, etc.</sup><br>
<sup id="fn3"><a href="#ref3">3</a>. power-seg is a segment's peak amplitude.  power-mean-seg is the average of the segment.</sup><br>
<sup id="fn4"><a href="#ref4">4</a>. f0-seg is the median f0, not a power weighted average.  Thus f0-seg will be a pitch actually present in the f0 time varying array.</sup><br>


<br><br>
Also note that any time varying descriptor can take a few different text string modifiers which come at the end of the descriptor string.

<table class="table-striped table-condensed">
<tr><th>Descriptor append string</th><th>Effect</th><th>Example</th></tr>
<tr><td>-delta</td><td>First order difference of the time varying series</td><td>centroid-delta = the first order difference of time varying centroids</td></tr>
<tr><td>-delta-seg</td><td>Average of the first order difference of the time varying series</td><td>centroid-delta-seg = a power-weighted average of the first order difference of time varying centroids</td></tr>
<tr><td>-deltadelta</td><td>Second order difference of the time varying series</td><td>power-deltadelta = the second order difference of time varying powers</td></tr>
<tr><td>-deltadelta-seg</td><td>Average of the second order difference of the time varying series</td><td>zeroCross-deltadelta-seg = a power-weighted average of the second order difference of time varying zero crossings</td></tr>
<tr><td>-slope-seg</td><td>Slope regression of the timevarying series</td><td>power-slope-seg = a linear regression descripbing the slope of the time varying series of powers</td></tr>
</table>

<br><br>
The SEARCH from the exampe below first takes the best 20% of corpus matches according to a linear regression of each segments amplitude.  Of the remaining 20% a segment is chosen based on a combination of the averaged first order different of f0 and the second order time varying centroids.
<pre class="language-python"><code class="language-python">SEARCH = [
spass('closest_percent', d('power-slope-seg'), percent=20), # take the best 20% of matches from the corpus
spass('closest', d('f0-delta-seg'), d('centroid-deltadelta')), # now find the best matching segment from the 20 percent that remains.
]
</code></pre>


</section>    



</div> <!--end Main Bar -->




<!--Nav Bar -->
<nav class="col-xs-3 bs-docs-sidebar">
<ul id="sidebar" class="nav nav-stacked fixed">
  <li><a href="#Installation">Installation</a></li>
  <li><a href="#QuickStart">Quick Start</a></li>
  <li><a href="#CorpusSegmentationwithagSegmentSfpy">Corpus Segmentation with agSegmentSf.py</a>
		<ul class="nav nav-stacked">
			 <li><a href="#FinessingCorpusSegmentation">Finessing Corpus Segmentation</a></li>
		</ul>
  </li>
  <li><a href="#ConcatenatingwithagConcatenatepy">Concatenating with agConcatenate.py</a>
		<ul class="nav nav-stacked">
			 <li><a href="#TheTARGETVariable">The TARGET Variable and tsf() object</a></li>
			 <li><a href="#TheCORPUSVariable">The CORPUS Variable and csf() object</a>
			 	  <ul class="nav nav-stacked">
					  <li><a href="#Whichsegmentsareaddedtothecorpus">Which Segments are Added to the Corpus</a></li>
					  <li><a href="#HowDirectoriesAreRead">How Directories Are Read</a></li>
					  <li><a href="#HowSegmentsWillBeConcatenated">How Segments Will Be Concatenated</a></li>
					  <li><a href="#Specifyingcsfkeywordsglobally">Specifying csf() Keywords Globally</a></li>
			 	  </ul>
			 </li>
			 <li><a href="#Descriptorsandthedobject">Descriptors and the d() object</a></li>
			 <li><a href="#SEARCHvariable">SEARCH variable and spass() object</a></li>
			 <li><a href="#TheSUPERIMPOSEvariabls">The SUPERIMPOSE variable and si() object</a></li>
			 <li><a href="#OtherOptions">Other Options</a>
			 	  <ul class="nav nav-stacked">
					  <li><a href="#DescriptorComputationParameters">Descriptor Computation Parameters</a></li>
					  <li><a href="#Concatenation">Concatenation</a></li>
					  <li><a href="#ConcatenationOutputFiles">Concatenation Output Files</a></li>
					  <li><a href="#OtherOutputFiles">Other Output Files</a></li>
					  <li><a href="#PrintingInteraction">Printing/Interaction</a></li>
					  <li><a href="#CsoundRendering">Csound Rendering</a></li>
			 	  </ul>
			 </li>
		</ul>
  </li>
  <li><a href="#DescriptorRetrieval">Descriptor Retrieval with agGetSfDescriptors.py</a></li>
  <li><a href="#Appendix1Descriptors">Appendix 1 - Descriptors</a></li>
</ul>
</nav>
</div>
 
 <script>
 // tell the embed parent frame the height of the content
 if (window.parent && window.parent.parent){
	window.parent.parent.postMessage(["resultsFrame", {
	  height: document.body.getBoundingClientRect().height,
	  slug: "v6zhz"
}], "*")
 }
</script>

</div>


</div>
</body>
</html>


