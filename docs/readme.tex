\documentclass{article}
\usepackage[margin=1.4in,footskip=0.25in]{geometry}
\setlength\parindent{0pt} % no indents
\usepackage{listings}
\usepackage{color}
\usepackage{longtable}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{parskip}
\usepackage{xspace}
\lstset{
backgroundcolor=\color{lbcolor}, tabsize=3, rulecolor=\color{white}, language=python, basicstyle=\scriptsize, upquote=true, aboveskip={0.75\baselineskip}, columns=fixed, showstringspaces=false, extendedchars=true, breaklines=true, prebreak=, breakindent=0.5em, frame=single, showtabs=false, showspaces=false, showstringspaces=false, identifierstyle=\ttfamily, keywordstyle=\color[rgb]{0,0,1}, commentstyle=\color[rgb]{0.133,0.545,0.133}, stringstyle=\color[rgb]{0.627,0.126,0.941}
}
\usepackage{color,hyperref}
\definecolor{darkblue}{rgb}{0.0,0.0,0.3}
\hypersetup{colorlinks,breaklinks,linkcolor=blue,urlcolor=blue,anchorcolor= blue,citecolor= blue,citebordercolor=Violet, filebordercolor=Red,linkbordercolor=Blue}
            
\newcommand{\figurewrap}[2]{\begin{figure}[h!]
\centering
\includegraphics[width=#2\textwidth]{#1}
\end{figure}}

\newcommand{\optEntry}[4]{\textbf{#1} (type=#2, default=#3) #4\hspace{0.5em}\\}
\newcommand{\ag}{audioguide1.1.0\xspace}
\newcommand{\Ag}{Audioguide1.1.0\xspace}

\usepackage[table]{xcolor}
\begin{document}
\setlength{\parskip}{10pt}
\begin{spacing}{1.2}
\begin{center}
\includegraphics[width=0.75\textwidth]{image0.png}

By Ben Hackbarth, Norbert Schnell, Philippe Esling, Diemo Schwarz, Gilbert Nouno. \\
Copyright Ben Hackbarth, 2011-2014.
\end{center}

\tableofcontents


\section{Installation}
The following lists the dependancies of \ag.  For the moment \ag only works on OS X.  Note that, regarding numpy, recent versions of OS X  (after 10.5) come with python2.7 that automatically has numpy installed.  This distribution of \ag comes with a precompiled version of pysdif for 64-bit python and, on more current machines, should run out of the box.  Here is a complete list of the resources that \ag requires on your computer:
\begin{description}
\item[pysdif] To compile install download the \href{http://sourceforge.net/projects/sdif/files/sdif/}{sdif library} and configure, make and install.  Then download my patched version of the \href{http://www.benhackbarth.com/audioGuide/release/pysdif-0.1.4-patch.zip}{pysdif module}.  `cd' into the directory when unzipped and run: `python2.7 setup.py install'.  You're now setup to use pysdif in python2.7.
\item[numpy] Most python2.7 installations come with numpy, a numerical computation module.  Upgrading to the latest python2.7 should get you there.  If you don't have it, you can download the source code or a binary installer \href{http://sourceforge.net/projects/numpy/files/NumPy/}{here}.
\item[csound6] Needed only if you would like \ag to automatically render concatenations (which you probably do).  Download an installer from \href{http://csound.github.io/download.html}{here}.
\item[matlibplot (optional)] Install this python module to enable graphing of descriptors and soundfile segmentation.  Get it from \href{http://matplotlib.org/downloads.html}{here}.
\item[supervp (optional)] Used to stretch a target before concatenating.
\end{description}

  


\section{Quick Start}
Using \ag comes down to interacting with python scripts in the \ag folder.  For soundfile concatenation, one script does segmentation of corpus soundfiles.  A second script performs concatenation based on a variety of variables found in a options file.  While you do not need to know how to write Python code in order to use \ag, it is not a bad idea to know some of Python's basic syntax.

The reason that segmentation and concatenation are separated into discrete steps that I find is useful to fine-tune the segmentation of corpus sounds \emph{before} using them in a concatenation.  Soundfile segmentation is a difficult technical problem and should remain conceptually and aesthetically open-ended.  I have yet to find an algorithm that does not require adjustments based on the nature of the sound in question and the intention of the user as to what a segment should be.


\subsection{Segmenting Corpus Soundfiles}
\emph{Note}: If you only want to use folders of sounds that have been pre-segmented into individual files, you can skip\footnote{But make sure tell \ag not to search for segmentation textfiles by setting the corpus attribute wholeFIle=True.  See the Manipulating How Directories Are Read subsection of the CORPUS options section for more info.} the \emph{Segmenting Corpus Soundfiles} section and proceed to the concatenation section.

The script you use to segment your corpus files with a script called `agSegmentSf.py'.  AgSegmentSf.py automatically creates a textfile which denotes the start and stop times of sound segments in a continuous audiofile.  Once you find a segmentation that you're happy with you're ready to use this sound file in the agConcatenate.py script.
Keep in mind that you do not \emph{need} to use agSegmentSf.py if you do not want to -- instead you could:
\begin{enumerate}
\item use whole soundfiles as segments
\item create segmentation files by hand
\item create segmentation files with other software as long the textfile is written in the same format as \ag's.
\end{enumerate}

To segment a corpus file, `cd' into the \ag folder and run the following command:

\begin{lstlisting}[language=python]
$ > python2.7 agSegmentSf.py examples/lachenmann.aiff
\end{lstlisting}

\ag will think for a second, and then output the following data detailing the segmentation of this audiofile:

\begin{lstlisting}[language=python]
---------------------- AUDIOGUIDE SEGMENT SOUNDFILE ----------------------

Evaluating /Users/ben/Documents/audioguide1.1/examples/lachenmann.aiff from 0.00-64.65

AN ONSET HAPPENS when
The amplitude crosses the Relative Onset Trigger Threshold: -40.00 (-t option)


AN OFFSET HAPPENS when
1. Offset Rise Ratio: when next-frame's-amplitude/this-frame's-amplitude >= 1.30 (-r option)
	...or...
2. Offset dB above minimum: when this frame's absolute amplitude <= -80.00 (minimum found amplitude of -260.00 plus the offset dB boost of 12.00 (-d option))


Found 144 segments
Wrote file /Users/ben/Documents/audioguide1.1/examples/lachenmann.aiff.txt
\end{lstlisting}

As a result of running this python script, \ag automatically writes a textfile with the exact same name and path as the soundfile, but adding the extension .txt -- in this case: examples/lachenmann.aiff.txt.  In this case \ag found 144 segments obtained using a triggering threshold of -40 dB, a rise ratio of 1.3 and a offset dB value of -80 (you can read more about how to alter these values and their effect in section \ref{segmentation}).

\subsection{Concatenating}
Once you have segmented corpus soundfiles to your satisfaction, you are ready to call the concatenation script agConcatenate.py with a special \ag options file as the first (and only) argument.  

To run one of the examples in the examples directory, run the following command inside the \ag directory:
\begin{lstlisting}[language=python]
python2.7 agConcatenate.py examples/01-simplest.py
\end{lstlisting}

..which will use the options contained in `examples/01-simplest.py' to parameterize the concatenative algorithm.  In this options file you specify a target sound, the corpus sounds, and (if you like) lots of other options that parameterize the concatenative process.  When run, the `agConcatenate.py' script will perform the following summarised operations:
\begin{enumerate}
\item Run an ircamdescriptor analysis of the soundfile in the TARGET variable\footnote{An SDIF analysis is only done once -- subsequent usages of this soundfile simply read SDIF data from disk.  Analysis files are stored in a directory called `\ag/data\_json/' in the \ag folder.  This directory can become quite large since these SDIF files are quite substantial in size.  Removing this folder will cause all SDIF files to be recomputed.}.  
\item Segment the target sound according to your options file.  An Audacity-style label file is created in a file called `output/tgtlabels.txt' in the output directory.
\item Run an ircamdescriptor analysis of the soundfiles in the CORPUS variable (only the first time each of these files are used).
\item (If you've specified them) Remove corpus segment according to descriptor limitations (Nothing above a certain pitch, nothing below a certain dynamic, etc.).
\item Normalise target and corpus descriptor data according to your options file.
\item Go through each target segment one by one.  Select corpus segment(s) to match each target segment according to the descriptors and search passes in the SEARCH variable of your options file.  Control over the layering and superimposition of corpus sounds is specified in the SUPERIMPOSE variable.
\item Write selected segments to a csound score called `output/output.csd'.  (In addition to the csd file there are many other types of outputs which you can read about in \ref{outputfiles}.
\item If you have csound, `output/output.csd' is rendered with csound to create an audiofile called `output/output.aiff'.
\item If you have csound, automatic playback of `output/output.aiff' at the command line.
\end{enumerate}


\section{Corpus Segmentation}\label{segmentation}
The textfiles created by agSegmentSf.py use a segmentation labeling format identical to that of the soundfile editor Audacity.  So, to examine your segments, open lachenmann.aiff in Audacity, then import labels and select `examples/lachenmann.aiff.txt'.

\figurewrap{image1.png}{1}

%Segmentation textfiles document one segment per line. here is an example line: `1.50 2.13 onset -12.9 offset rise 1.33'.
%
%Everything after startSec and endSec is not required by \ag, but give you information about the segmentation logic.  These fields correspond to: startSec endSec onset thresholdValue offset offsetMethod methodValue.
%
%.. and indicate ..
%
%\subsection{Onset Detection}
%thresholdValue: the value of the threshold which triggered this segment's onset. it is in negative dB where -100 dB is very soft and -6 dB is very loud. you can change the threshold level that triggers onsets by passing the agSegmentSf.py script a `-t' flag:
%\begin{lstlisting}[language=python]
%./agSegmentSf.py -t -30 soundfilename.wav
%\end{lstlisting}
%...sets the threshold to -30. it will produce less onsets then -40 (the default).
%
%\subsection{Offset Detection}
%\ag's soundfile segmentation uses two methods for creating an offset (an offset means to end a currently active sound segment).  
%The first method is simple -- if the amplitude of a segment drops below a certain dB threshold, called `drop' and can be changed from its default value using the `-d' flag.
%
%\begin{lstlisting}[language=python]
%python2.7 agSegmentSf.py -d 4 soundfilename.wav
%\end{lstlisting}
%
%... which changes the drop dB value to 4 dB above the minimum amplitude found in the entire soundfile.
%
%The second method is more complicated: if the amplitude of the sound is louder that the previous value and the ratio of the current value over the previous value is above the `rise ratio'.  This is a very useful construct: imagine that you are in a current sound segment, but the soundfile suddenly gets much louder, and you'd like to end the current segment so that you may start a new one which reflects this change.  You can override the default rise ratio (1.1) using the `-r' flag:
%
%\begin{lstlisting}[language=python]
%python2.7 agSegmentSf.py -r 4 soundfilename.wav
%\end{lstlisting}
%
%...a value of 1.1 will be quite sensitive to changes in amplitude.  A value of 4 will be less sensitive - a larger crescendo is needed to turn off a currently active segment.
%
%Note that to segment a whole directory of soundfiles, you may use wildcard characters in the bash shell, as in:
%\begin{lstlisting}[language=python]
%python2.7 agSegmentSf.py mydir/*.aiff # create a segmentation file for each aiff file located in mydir/
%\end{lstlisting}

\section{The Concatenation Options File}
The options file used by the concatenate script is a python file that defines a bunch of variables.  Most variables can be changed with simple assignments using the `=' symbol.  For instance, to change the path of the csound output sound file, write the following in your myOptions.py file:
\begin{lstlisting}
CSOUND_RENDER_FILEPATH = '/path/to/the/file/i/want.aiff' # sets the path of the csound output aiff file
DESCRIPTOR_HOP_SIZE_SEC = 0.02049 # change the analysis hop size
\end{lstlisting}


However, there are five custom objects that are written into the options file as well -- tsf(), csf(), spass(), d() and si().  These objects take required parameters \emph{and also} take keyword arguments.  The following sections describe the object-style variables; Section \ref{otheroptions} details variables changed with the `=' symbol.

\section{The TARGET Variable and tsf() object}\label{target}
The TARGET variable is written as a tsf() object which requires a path to a soundfile and also takes the following optional keyword arguments:

\begin{lstlisting}[language=python]
tsf('pathtosoundfile', start=0, end=file-length, thresh=-40, offsetRise=1.5, offsetThreshAdd=+12, offsetThreshAbs=-80, scaleDb=0, minSegLen=0.05, maxSegLen=1000, midiPitchMethod='composite', stretch=1, segmentationFilepath=None)
\end{lstlisting}

\begin{description}
\item[start] The time in seconds to start reading the target soundfile.
\item[end] The time in seconds to stop reading the target soundfile.  
\item[thresh] Segmentation onset threshold: a value from -100 to 0.  The lower the value the soft the target's amplitude can be in order to trigger a selection from the corpus.  So, -12 yields fewer corpus selections that -24.  
\item[offsetRise] Segmentation offset ratio: a number greater than 1.   During segmentation the rise-ratio is the ratio of a frame's amplitude to the next frame's amplitude.   In an active segment, if this ratio is greater than user-supplied rise-ratio, it will cause an offset.
\item[offsetThreshAdd] Segmentation offset relative threshold: a positive value in dB.  
This value is added to the soundfile's minimum amplitude.  During segmentation, if a frame's amplitude is below this threshold, it causes a segment offset.  Also see offsetThreshAbs.
\item[offsetThreshAbs] Segmentation offset absolute threshold: a negative value in dB.  When segmenting the target, if a frame's amplitude is below this value it will cause an offset.  This variable is an absolute value while offsetThreshAdd is relative to the soundfile's minimum amplitude.  Effectively, whichever of these two variable is closer to 0 will be the offset threshold.
\item[minSegLen*] Segmentation: the minimum duration in seconds of a target segment.
\item[maxSegLen*] Segmentation: the maximum duration in seconds of a target segment.

\item[scaleDb*] Applies an amplitude change to the whole target sound. By default, it is 0, yielding no change. -6 = twice as soft.  The target's amplitude will usually affect concatenation: the louder the target, the more corpus sounds can be composited to approximate it's energy profile.

\item[midiPitchMethod] same as corpus method documented in \ref{midipitchmethod}.
\item[stretch*] Uses SuperVp to time stretch/compress the target sound before analysis and concatenation.  Stretched sound files are saved and reused in the audioguide/data\_stretched\_sfs directory.  A value of 1, the default, will cause no time stretching to be applied.  Note that, in order to use this option, you must set the SUPERVP\_BIN variable in the audioguide/defaults.py file.
\item[segmentationFilepath] by default the Target sound is segmented at runtime.  However, if you'd like to specify a user-defined segmentation, you may give a file path to this variable.  Note that this file must be a textfile with the same format as corpus segmentation files.
\end{description}


\begin{lstlisting}[language=python]
TARGET = tsf('cage.aiff') # uses the whole soundfile at its given amplitude
TARGET = tsf('cage.aiff', start=5, end=7, scaleDb=6) # only use seconds 5-7 of cage.aiff at double the amplitude.
\end{lstlisting}


\section{The CORPUS Variable and csf() object}
The CORPUS variable is defined as a list of csf() objects which require a path to a soundfile OR a directory.  File paths and/or directory paths may be full paths or relative paths to the location of the options file you're using or a path found in the SEARCH\_PATHS variable.  A csf() object required the soundfile/directory name, then takes the following optional keyword arguments:

\begin{lstlisting}[language=python]
csf('pathToFileOrDirectoryOfFiles', start=None, end=None, includeTimes=[], excludeTimes=[], limit=[], wholeFile=False, recursive=True, includeStr=None, excludeStr=None, scaleDb=0.0, limitDur=None, onsetLen=0.01, offsetLen='30%', postSelectAmpBool=False, postSelectAmpMethod='power-mean-seg', postSelectAmpMin=-12, postSelectAmpMax=+12, midiPitchMethod='composite', transMethod=None,  transQuantize=0, allowRepetition=True, restrictRepetition=0.5, restrictOverlaps=None, restrictInTime=0, scaleDistance=1, superimposeRule=None, segmentationFile=None, segmentationExtension='.txt')
\end{lstlisting}

The simplest way to include a soundfile in your corpus is to use its path as the first argument of the csf() object:
\begin{lstlisting}
CORPUS = [csf("lachenmann.aiff")] # will search for a segmentation file called lachenmann.aiff.txt and add all of its segments to the corpus
\end{lstlisting}

The simplest way to include a directory of soundfiles in your corpus is to use its path as the first argument of the csf() object:
\begin{lstlisting}
CORPUS = [csf("lachenmann.aiff"), csf('piano')] # will use segments from lachenmann.aiff as well as all sounds in the directory called piano
\end{lstlisting}

\noindent However, as you can see above, each csf() object has \emph{a lot} of optional arguments to give you better control over what segments are used, how directories are read and how segments are treated during concatenation.  

\emph{Note: Each of these keyword arguments \emph{only} apply to the csf() object within which they are written.  If you'd like to specify these parameters for the entire corpus, see \ref{globalcorpus}.}

\subsection{Manipulating which segments are added to the corpus}
\begin{description}
\item[start] Any segments which start before this time will be ignored.
\item[end] Any segments which start after this time will be ignored.
\end{description}

\begin{lstlisting}[language=python]
csf('lachenmann.aiff', start=20) # only use segments who start later than 20s.
csf('lachenmann.aiff', start=20, end=50) # only use segments who start between 20-50s.
\end{lstlisting}

\begin{description}
\item[includeTimes*] A list of two-number lists which specify regions of segments to include from this file's list of segment times.  See example below.
\item[excludeTimes*] Same as includeTimes but excludes segments in the identified regions.
\end{description}

\begin{lstlisting}
csf('lachenmann.aiff', includeTimes=[(1, 4), (10, 12)]) # only use segments falling between 1-4 seconds and 10-12 seconds.
csf('lachenmann.aiff', excludeTimes=[(30, 55)]) # use all segments except those falling between 30-55s.
\end{lstlisting}

\begin{description}
\item[limit*] A list of equation-like strings where segmented descriptor names are used to include/exclude segments from this file / directory.
\end{description}
\begin{lstlisting}
csf('lachenmann.aiff', limit['centroid-seg >= 1000']) # segments whose centroid-seg is equal to or above 1000.

csf('lachenmann.aiff', limit['centroid-seg < 50%']) # only use 50% of segments with the lowest centroid-seg.

csf('lachenmann.aiff', limit['power-seg < 50%', 'power-seg > 10%']) # only use segments whose power-seg falls between 10%-50% of the total range of power-seg's in this file/directory.
\end{lstlisting}
\begin{description}
\item[segmentationFile*] Manually specify the segmentation text file. By default, \ag automatically looks for a file with the same name as the soundfile plus the extension `.txt'. You may specify a path file (as a string), or a list of strings to include multiple segmentation files which all use the same soundfile.

\item[segmentationExtension*] Manually specify the segmentation text file extension.  See above.
\end{description}

\begin{lstlisting}
csf('lachenmann.aiff', segmentationFile='marmotTent.txt') # will use a segmentation file called marmotTent.txt, not the default lachenmann.aiff.txt.

csf('lachenmann.aiff', segmentationExtension='-gran.txt') # will use a segmentation file called lachenmann.aiff-gran.txt, not the default lachenmann.aiff.txt.
\end{lstlisting}




\subsection{Manipulating How Directories Are Read}
The following keyword arguments are useful when dealing with directories of files.
\begin{description}
\item[wholeFile*] if True \ag will use this soundfile as one single segment.  If False, \ag will search for a segmnetation file made with agSegmentSf.py.

\item[recursive*] if True \ag will include sounds in all subfolders of a given directory.
\end{description}

\begin{lstlisting}
csf('sliced/my-directory', wholeFile=True) # will not search for a segmentation txt file, but use whole soundfiles as single segments.

csf('/Users/ben/gravillons', recursive=False) # will only use soundfiles in the named folder, ignoring its subdirectories.
\end{lstlisting}

\begin{description}
\item[includeStr*] A string which is matched against the filename (not full path) of each soundfile in a given directory.  If part of the soundfile name matches this string, it is included.  If not it is excluded.  This is case sensitive.  See example below.

\item[excludeStr*] Opposite of includeStr.
\end{description}

\begin{lstlisting}
# includeStr/excludeStr have lots of uses.  One to highlight here: working with sample databases which are normalized.  Rather than having each corpus segment be at 0dbs, we apply a scaleDb value based on the presence of a `dynamic' written into the filename.
csf('Vienna-harpNotes/', includeStr=['_f_', '_ff_'], scaleDb=-6),
csf('Vienna-harpNotes/', includeStr='_mf_', scaleDb=-18),
csf('Vienna-harpNotes/', includeStr='_p_', scaleDb=-30),
# this will use all sounds from this folder which match one of the three dynamics.
\end{lstlisting}





\subsection{Manipulating How Segments Will Be Concatenated}
\begin{description}
\item[scaleDb*] applies an amplitude change to each segment of this collection. by default, it is 0, yielding no change. -6 = twice as soft.  Note that amplitude scaling affects both the concatenative algorithm and the csound rendering.  

\item[limitDur*] limits the duration of each segment from this csf() entry.  The duration of all segments over this value (in seconds) will be truncated.  

\item[onsetLen*] if onsetLen is a float or integer, it is the fade-in time in seconds.  If it is a string formed as '10\%', it is interpreted as a percent of each segment's duration.  So, onsetLen=0.1 yields a 100 ms. attack envelope while onsetLen='50\%' yields a fade in over 50\% of the segment's duration.

\item[offsetLen*] Same as onsetLen, but for the envelope fade out.

\end{description}
\begin{lstlisting}
csf('lachenmann.aiff', onsetLen=0.1, offsetLen='50%') # will apply a 100ms fade in time and a fade out time lasting 50% of each segments' duration.
\end{lstlisting}
\begin{description}

\item[postSelectAmpBool*] If True, \ag will attempt to change the amplitude of selected segments to match the amplitude of the target.  The default, False, makes no adjustment.
\item[postSelectAmpMethod*] Tells \ag how to attempt to match corpus and target amplitudes.  It is only meaningful if postSelectAmpMethod is True:
\begin{description}
\item[`power-mean-seg'] will use the mean of segment powers' to change adjust selected segments amplitudes.  
\item[`power-seg'] will adjust amplitudes according to peak amplitudes.  
\end{description}
\item[postSelectAmpMin*] If postSelectAmpBool is True, this value in dB limits the lower threshold of the amplitude change.  0=no change, -6=half volume, etc.
\item[postSelectAmpMax*] If postSelectAmpBool is True, this value in dB limits the upper threshold of the amplitude change.  0=no change, +6=double volume, etc.

\item[midiPitchMethod*]\label{midipitchmethod} this tells \ag how got calculate a midipitch for each segment.  There are several possibilities, detailed below.  Note that if any of these methods do not find a result, -1 is returned.  This attribute is used when writing midi output files.  This data is also accessible as the descriptor d(`MIDIPitch-seg').
\begin{description}
\item[`f0-seg'] returns the averaged f0 array as the midipitch.  Note that it is not power weighted - it is actually the median of f0.
\item[`centroid-seg'] returns the power averaged centroid converted into a midipitch.
\item[`filename'] looks at the filename of the corpus segment to see if there is a midipitch indicated.  Names like A1ShortSeq.wav, Fs1ShortSeq.wav and BP-flatter-f-A\#3.wav work.
\item[`composite'] first tries to look for a midipitch in the filename.  If not found, then tries `f0-seg'.
\end{description}

\item[transMethod*] A string indicating how to transpose segments chosen from this corpus entry.  You may chose from:
\begin{description}
\item[None] yields no transposition.
\item[`single-pitch n'] transposes all selected segments from this csf() to midipitch n.
\item[`random n m'] transposes this segment randomally between midipitch n and m.
\item[`f0'] transposes a selected corpus segment to match the f0-seg of the corresponding target segment.
\item[`f0-chroma'] transposes a selected corpus segment to match the f0-seg of the corresponding target segment modulo 12 (i.e., matching its chroma).
\end{description}

\item[transQuantize*] Quantization interval for transposition of corpus sounds.  1 will quantize to semitones, 0.5 to quarter tones, 2 to whole tones, etc.

\end{description}
\begin{lstlisting}
csf('piano/', transMethod='f0') # transpose corpus segments to match the target's f0.
csf('piano/', transMethod='f0-chroma', transQuantize=0.5) # transpose corpus segments to match the target's f0 mod 12.  Then quantize each resulting pitch to the newest quarter of tone.
\end{lstlisting}
\begin{description}

\item[allowRepetition*] If False, any of the segments from this corpus entry may only be picked one time.  If True there is no restriction.

\item[restrictRepetition*] A delay time in seconds where, once chosen, a segment from this corpus entry is invalid to be picked again.  The default is 0.1, which the same corpus segment from being selected in quick succession.

\end{description}
\begin{lstlisting}
csf('piano/', allowRepetition=False) # each individual segment found in this directory of files may only be deleted one time during concatenation.
csf('piano/', restrictRepetition=2.5) # Each segment is invalid to be picked if it has already been selected in the last 2.5 seconds.
\end{lstlisting}
\begin{description}


\item[restrictOverlaps*] An integer specifying how many overlapping samples from this collection may be chosen by the concatenative algorithm at any given moment.  So, restrictOverlaps=2 only permits 2 overlapping voices at a time.

\item[restrictInTime*] a time in seconds specifying how often a sample from this entry may be selected. -- for example restrictInTime=0.5 would permit segments from this collection to be select a maximum of once every 0.5 seconds.

\item[scaleDistance*] Scale the resulting distance when executing a multidimensional search using on segments.  scaleDistance=2 will make these sounds twice as `far', and thus less likely to be selected by the search algorithm.  scaleDistance=0.25 makes 4 times more likely to be picked.

\item[superimposeRule*]  This one is a little crazy.  Basically, you can specify when this corpus's segments can be chosen based on the number of simultaneously selected samples.  You do this by writing a little equation as a 2-item list.  superimposeRule=(`==', 0) says that this set of corpus segments may only be chosen is this is the first selection for this target segment (sim selection `0').  superimposeRule=(`>', 2) say this corpus's segments are only valid to by picked if there are already more than 2 selections for this target segment.  I know, right?
\end{description}


\subsection{Specifying csf() keywords globally}\label{globalcorpus}
csf() keywords may be specified globally using the variable CORPUS\_GLOBAL\_ATTRIBUTES.  Note that they are specified in dictionary format rather than object/keyword format.

\begin{lstlisting}
CORPUS = [csf('lachenmann.aiff', scaleDb=-6), csf('piano/', scaleDb=-6, wholeFile=True)]

# is equivalent to 

CORPUS = [csf('lachenmann.aiff'), csf('piano/', wholeFile=True)]
CORPUS_GLOBAL_ATTRIBUTES = {'scaleDb': -6}
\end{lstlisting}


\section{SEARCH variable and spass() object}
The SEARCH variable specifies how \ag picks corpus segments to match target segments.  The idea here is make a \emph{very} flexible searching structure where the user can create multiple search passes on different descriptor criteria.

The SEARCH variable is written as a list of spass() objects.  Each spass() has the following parameters: 
\begin{lstlisting}
spass(search_type, descriptor1... descriptorN, percent=None, minratio=None, maxratio=None)
\end{lstlisting}

And the search\_type string may be among the following methods:
\begin{description}
\item[`closest'] Return the best matching segment.
\item[`closest\_percent'] Return the top \emph{percent} percent of the best matching segments.
\item[`farthest'] Return the worst matching segment.
\item[`farthest\_percent'] Return the worst \emph{percent} percent of segments.
\item[`ratio\_limit'] Return segments where the ratio of the target descriptor value to the segment's value falls between minratio and maxratio.  Only works for averaged descriptors.
\end{description}


Here is the most simple case of a SEARCH variable:
\begin{lstlisting}
SEARCH = [spass('closest', d('centroid'))] # will search all corpus segments and select the one with the `closest' centroid to the target segment.
\end{lstlisting}

Note that the first argument is the type of search performed -- in this case, selecting the closest sample.  Following the arguments are a list of descriptor objects which specify which descriptors to use:

\begin{lstlisting}
SEARCH = [spass('closest', d('centroid'), d('effDur-seg'))] # will search all corpus segments and select the one with the `closest' centroid and effective duration compared to the target segment.
\end{lstlisting}

Ok, great.  As you can probably imagine, the first argument, `closest', tells \ag to pick the closest sound.  But, there are also other possibilities:

\begin{lstlisting}
SEARCH = [spass('farthest', d('centroid'))] # return the worst matching segment.

SEARCH = [spass('closest_percent', d('centroid'), percent=20)] # return the top 20 percent best matches.

SEARCH = [spass('farthest_percent', d('centroid'), percent=20)] # return the worst 20 percent of matches.
\end{lstlisting}

If you use `closest\_percent' or `farthest\_percent' as the one and only spass object in the SEARCH variable, \ag will select a corpus segment randomly among the final candidates.  However, you can also chain spass objects together, essentially constructing a hierarchical search algorithm.  So, for example, take the following SEARCH variable with two separate phases:

\begin{lstlisting}
SEARCH = [
spass('closest_percent', d('effDur-seg'), percent=20), # take the best 20% of matches from the corpus
spass('closest', d('mfccs')), # now find the best matching segment from the 20 percent that remains.
] 
\end{lstlisting}

I use the above example a lot when using \ag.  It first matches effDur-seg, the effective duration of the target measured agains't the effective duration of each corpus segment.  It retains the 20\% closest matches, and throws away the worst 80\%.  Then, with the remaining 20\%, the timbre of the sounds are matched according to mfccs.

\begin{lstlisting}
SEARCH = [spass('ratio_limit', d('centroid-seg'), minratio=0.9, maxratio=1.1)] # reduce the number of samples in the corpus such 
\end{lstlisting}

Remember, the order of the spass objects in the SEARCH variable is very important -- it is essentially the order of operations.

\section{The d() object}
Use the d() object for parameterizing a descriptor in an spass() object.  The d() object take 1 argument -- the name of the desired descriptor --  and then several optional keywords arguments, detailed below.

 \begin{lstlisting}[language=python]
d('descriptor name', weight=1, norm=2, normmethod='stddev', distance='euclidean', energyWeight=False)
\end{lstlisting}
 
\begin{description}
\item[weight*] How to weight this descriptor in relation to other descriptors.

\begin{lstlisting}
SEARCH= [spass('closest', d('centroid', weight=1), d('noisiness', weight=0.5))] # centroid is twice as important as noisiness.
\end{lstlisting}

\item[norm*] A value of 2 normalizes the target and corpus data separately.  A value of 1 normalizes the target and corpus data together.  2 will yield a better rendering of the target's morphological contour.  1 will remain more faithful to concrete descriptor values.  I recommend using 2 by default, only using 1 when dealing with very `descriptive' descriptors like duration or pitch.

\begin{lstlisting}
SEARCH= [spass('closest', d('centroid'), d('effDur-seg', norm=1))]
\end{lstlisting}

\item[normmethod*] How to normalize data -- either `stddev' or `minmax'.  minmax is more precise, stddev is more forgiving of `outliers.'

\item[distance*] Only valid for time-varying descriptors.  How to arithmetically measure distance between target and corpus arrays.  `euclidean' does a simple least squares distance.  Other methods include `pearson'.

\begin{lstlisting}
SEARCH= [spass('closest', d('centroid', distance='pearson'))] # uses a pearson correlation formula for determining distance between target and corpus centroid arrays.
\end{lstlisting}

\item[energyWeight] Only valid for time-varying descriptors.  Weight distance calculations with the corpus segments' energy values.  The means that softer frames will not affect distance as much as louder frames.
\end{description}


\section{The SUPERIMPOSE variable and si() object}
Use the si() object for specifying how corpus segments may be superimposed during concatenation.

 \begin{lstlisting}[language=python]
SUPERIMPOSE = si(minSegment=None, maxSegment=None, minOnset=None, maxOnset=8, minOverlap=None, maxOverlap=None, searchOrder='power', calcMethod='mixture', peakAlign=False)
\end{lstlisting}
 
\begin{description}

\item[minSegment] The minimum number of corpus segments that must be chosen to match a target segment.
\item[maxSegment] The maximum number of corpus segments that must be chosen to match a target segment.
\item[minOnset] The minimum number of corpus segments that must be chosen to begin at any single moment in time.
\item[maxOnset] The maximum number of corpus segments that must be chosen to begin at any single moment in time.
\item[minOverlap] The minimum number of overlapping corpus segments at any single moment in time.  Note that an `overlap' is determined according to an amplitude threshold -- see overlapAmpThresh.
\item[maxOverlap] The maximum number of overlapping corpus segments at any single moment in time.  Note that an `overlap' is determined according to an amplitude threshold -- see overlapAmpThresh.

\item[searchOrder] (`power' or `time')  The default is `time', which indicated to match corpus segments to target segments in the temporal order of the target (i.e., first searched segment is the first segment in time).  `power' indicates to first sort the target segments from loudest to softest, then search for corpus matches.

\item[calcMethod] A None/string which denotes how to calculate overlapping corpus sounds.  None does nothing -- each corpus selection is unaware of previous selections.  `subtract' subtracts the energy of a selected corpus sound from the target's amplitude so that future selections factor in the amplitude of past selections.  `mixture' subtracts the amplitude and then attempts to mix the descriptors of simultaneous sounds together.  Note that some descriptors are not algorithmically mixable, such as f0, zeroCross.
\end{description}




\section{Other Options}\label{otheroptions}
\subsection{Descriptor Computation Parameters}
\optEntry{DESCRIPTOR\_FORCE\_ANALYSIS}{bool}{False}{if True, \ag is forced to remake all SDIF analysis, even if previously made.}

\optEntry{DESCRIPTOR\_WIN\_SIZE\_SEC}{float}{0.04096}{the FFT window size of descriptor analysis in seconds.  0.04096 seconds = 512 @ 12.5kHz (the default resample rate).}

\optEntry{DESCRIPTOR\_HOP\_SIZE\_SEC}{float}{0.01024}{the FFT window overlaps of descriptor analysis in seconds.  Important, as it effectively sets of temporal resolution of \ag.}

\optEntry{IRCAMDESCRIPTOR\_RESAMPLE\_RATE}{int}{25000}{The internal resample rate of the IRCAM analysis binary.  Important, as it sets the frequency resolution of spectral sound descriptors.}

\optEntry{IRCAMDESCRIPTOR\_WINDOW\_TYPE}{string}{blackman}{see ircamdescriptor documentation for details.}

\optEntry{IRCAMDESCRIPTOR\_NUMB\_MFCCS}{int}{13}{sets the number of MFCCs to make.  \emph{Doesn't seem to work} in this release, as 13 is all I can ever seem to get out of the library.}

\optEntry{IRCAMDESCRIPTOR\_F0\_MAX\_ANALYSIS\_FREQ}{float}{5000}{see ircamdescriptor documentation for details.}

\optEntry{IRCAMDESCRIPTOR\_F0\_MIN\_FREQUENCY}{float}{20}{minimum possible f0 frequency.}

\optEntry{IRCAMDESCRIPTOR\_F0\_MAX\_FREQUENCY}{float}{5000}{maximum possible f0 frequency.}

\optEntry{IRCAMDESCRIPTOR\_F0\_QUALITY}{float}{0.1}{see ircamdescriptor documentation for details.}

\optEntry{SUPERVP\_BIN*}{string/None}{None}{Optionally specify a path to the supervp analysis binary.  Used for target pre-concatenation time stretching.}

%\optEntry{PM2\_BIN*}{string/None}{None}{Optionally specify a path to the pm2 analysis binary.  Currently not implemented.}


\subsection{Concatenation}
\optEntry{ROTATE\_VOICES*}{bool}{False]}{if True, \ag will rotate through the list of corpus entries during concatenation.  This means that, when selecting corpus segment one, \ag will only search sound segments from the first item of the CORPUS variable.  Selection 2 will only search the second, and so on.  Corpus rotation is modular around the length of the CORPUS variable.  If the corpus only has one item, True will have no effect.}

\optEntry{VOICE\_PATTERN*}{list}{[]}{if an empty list, this does nothing.  However, if the user gives a list of strings, \ag will rotate through this list of each concatenative selection and only use corpus segments who's filepath match this string.  Matching can use parts of the filename, not necessarily the whole path and it is not case sensitive.}

\optEntry{OUTPUT\_QUANTIZE\_TIME\_METHOD*}{string/None}{None}{controls the quantisation of the start times of events selected during concatenation.  Note that any quantisation takes place after the application of OUTPUT\_TIME\_STRETCH and OUTPUT\_TIME\_ADD, as detailed below.  This variable has the following possible settings:
\begin{description}
\item[None] no quantisation takes place (the default).
\item[`snapToGrid'] conform the start times of events to a grid spaced in OUTPUT\_QUANTIZE\_TIME\_INTERVAL second slices.
\item[`medianAggregate'] change each event's start time to the median start time of events in slices of OUTPUT\_QUANTIZE\_TIME\_INTERVAL seconds.  
\end{description}
}

\optEntry{OUTPUT\_QUANTIZE\_TIME\_INTERVAL*}{float}{0.25}{defines the temporal interval in seconds for quantisation.  If OUTPUT\_QUANTIZE\_TIME\_METHOD = None, this doesn't do anything.}

\optEntry{OUTPUT\_GAIN\_DB*}{int/None}{None}{adds a uniform gain in dB to all selected corpus units.  Affects the subtractive envelope calculations and descriptor mixtures as well as csound rendering.}

\optEntry{OUTPUT\_TIME\_STRETCH*}{float}{1.}{stretch the temporality of selected units.  A value of 2 will stretch all events offsets by a factor of 2.}

\optEntry{OUTPUT\_TIME\_ADD*}{float}{0.}{offset the start time of selected events by a value in seconds.}

\optEntry{RANDOM\_SEED*}{int/None}{None}{sets the pseudo-random seed for random unit selection.  By default a value of None will use the system's timestamp.  Setting an integer will create repeatable random results.}


\subsection{Concatenation Output Files}\label{outputfiles}
For each of the following *\_FILEPATH variables, a value of None tells the agConcatenate.py NOT to create an output file.  Otherwise a string tells agConcatenate.py to create this output file and also indicates the path of the file to create.  Strings may be absolute paths.  If a relative path is given, \ag will create the file relative to the location o the agConcatenate.py script.

\optEntry{CSOUND\_CSD\_FILEPATH}{string/None}{output/output.csd}{creates an output csd file for rendering the resulting concatenation with csound.}

\optEntry{CSOUND\_RENDER\_FILEPATH}{string/None}{output/output.aiff}{sets the sound output file in the CSOUND\_CSD\_FILEPATH file.  This is the name of csound's output soundfile and will be created at the end of concatenation.}

\optEntry{MIDI\_FILEPATH}{string/None}{output/output.mid}{a midi file of the concatenation with pitches chosen according to midiPitchMethod from each corpus entry.}

\optEntry{SUPERIMPOSITION\_LABEL\_FILEPATH}{string/None}{output/superimpositionlabels.txt}{Audacity-style labels showing the selected corpus sounds and how they overlap.}

\optEntry{LISP\_OUTPUT\_FILEPATH}{string/None}{output/output.lisp.txt}{a textfile containing selected corpus events as a lisp-style list.}

\optEntry{DATA\_FROM\_SEGMENTATION\_FILEPATH}{string/None}{None}{This file lists all of the extra data of selected events during concatenation.  This data is taken from corpus segmentation files, and includes everything after the startTime and endTime of each segment.  This is useful if you want to tag each corpus segment with text based information for use later.}

\optEntry{DICT\_OUTPUT\_FILEPATH}{string/None}{output/output.json}{a textfile containing selected corpus events in json format.}

\optEntry{MAXMSP\_OUTPUT\_FILEPATH}{string/None}{output/output.maxmsp.json}{a textfile containing a list of selected corpus events.  Data includes starttime in MS, duration in MS, filename, transposition, amplitude, etc.}


\subsection{Other Output Files}\label{otheroutputfiles}
For each of the following *\_FILEPATH variables, a value of None tells the agConcatenate.py NOT to create an output file.  Otherwise a string tells agConcatenate.py to create this output file and also indicates the path of the file to create.  Strings may be absolute paths.  If a relative path is given, \ag will create the file relative to the location o the agConcatenate.py script.

\optEntry{LOG\_FILEPATH}{string/None}{output/log.txt}{a log file with lots of information from the concatenation algorithm.}

\optEntry{TARGET\_SEGMENT\_LABELS\_FILEPATH}{string/None}{output/targetlabels.txt}{Audacity-style labels showing how the target sound was segmented.}

\optEntry{TARGET\_SEGMENTATION\_GRAPH\_FILEPATH}{string/None}{None}{like TARGET\_SEGMENT\_LABELS\_FILEPATH, this variable creates a file to show information about target segmentation.  Here however, the output is a jpg graph of the onset and offset times and the target's power.  This output requires you to install python's module matplotlib.}

\optEntry{TARGET\_DESCRIPTORS\_FILEPATH}{string/None}{targetdescriptors.json}{saves the loaded target descriptors to a json dictionary.}

\optEntry{TARGET\_PLOT\_DESCRIPTORS\_FILEPATH}{string/None}{None}{creates a plot of each target descriptor used in concatenation.  Doesn't work for averaged descriptors (``-seg''), only time varying descriptors.}



\subsection{Printing/Interaction}
\optEntry{SEARCH\_PATHS*}{list}{[]}{a list of strings, each of which is a path to a directory where soundfile are located.  These paths extend the list of search paths that \ag examines when searching for target and corpus soundfiles.  The default is an empty list, which doesn't do anything.}

\optEntry{VERBOSITY*}{int}{2}{affects the amount of information \ag prints to the terminal.  A value of 0 yields nothing.  A value of 1 prints a minimal amount of information.  A value of 2 (the default) prints refreshing progress bars to indicate the progress of the algorithms.}

\optEntry{PRINT\_SELECTION\_HISTO}{bool}{False}{if True will print robust information about corpus selection after concatenation.  If false (the default) will add this information to the log file, if used.}

\optEntry{PRINT\_SIM\_SELECTION\_HISTO}{bool}{False}{if True will print robust information about corpus overlapping selection after concatenation.  If false (the default) will add this information to the log file, if used.}


\subsection{Csound Rendering}
\optEntry{CSOUND\_SR*}{int}{48000}{The sample rate used for csound rendering.  Csound will interpolate the sample rates of all corpus files to this rate.  It will be the sr of csound's output soundfile.}

\optEntry{CSOUND\_KR*}{int}{128}{The control rate used for csound rendering.  See csound's documentation for more information.}

\optEntry{CSOUND\_CHANNEL\_RENDER\_METHOD}{string}{``mix''}{Tells \ag how deal with corpus segments distribution in the output soundfile  By default`'mix'' creates a 2 channel csound file and puts mono corpus sounds in the middle of the stereo field.  The string ``oneChannelPerVoice'' tells audioguide to put selected sounds from each item of the CORPUS list into a separate channel.  The number of output channels will therefore equal the length of the CORPUS list variable.}

\optEntry{CSOUND\_STRETCH\_CORPUS\_TO\_TARGET\_DUR*}{string/None}{None}{Affects the durations of concatenated sound events rendered by csound.  By default None doesn't do anything -- csound plays back each corpus sound according to its duration.  ``pv'' uses a phase vocoder to stretch corpus sounds to match the duration of the corresponding target segment.  ``transpose'' does the same, but using the speed of playback to change duration rather than a phase vocoder.  Note that, in this case, any other transposition information generated by the selection algorithm is overwritten.}

\optEntry{CSOUND\_PLAY\_RENDERED\_FILE*}{bool}{True}{if True, \ag will play the rendered csound file at the command line at the end of the concatenative algorithm.}



\end{spacing}
\end{document}

 

